策略模式主要用于允许我们的程序在运行时动态更改一个任务的处理逻辑，常见的应用场景有针对软件用户群体的不同策略切换和业务流程兜底切换。
策略模式要解决的问题是，让使用客户端跟具体执行任务的策略解耦，不管使用哪种策略完成任务，不需要更改客户端使用策略的方式。

策略模式主要有四类角色：
客户端：这个客户端可以简单理解成是发起任务调用的代码。
抽象策略：就是上面定义中的算法族，是所有具体策略的通用接口，声明了用于执行完成任务的方法。
具体策略：实现了抽象策略，定义了具体应该怎么完成任务。
上下文：作为客户端和具体策略的中间层，达到客户端与具体策略解耦的效果，它维护指向具体策略的引用，且仅通过抽象策略中定义的接口与具体策略进行交流。
常用的实现方式是通过组合。

细节：上下文对象引用具体策略类的时候，使用的是组合的方式，让其私有属性指向策略接口的具体实现，这样就能完成在运行时修改执行任务的具体策略的效果。


策略模式（Strategy Pattern）定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。

在什么时候，我们需要用到策略模式呢？
在项目开发中，我们经常要根据不同的场景，采取不同的措施，也就是不同的策略。比如，假设我们需要对 a、b 这两个整数进行计算，根据条件的不同，
需要执行不同的计算方式。我们可以把所有的操作都封装在同一个函数中，然后通过 if … else … 的形式来调用不同的计算方式，
这种方式称之为硬编码。

在实际应用中，随着功能和体验的不断增长，我们需要经常添加 / 修改策略，这样就需要不断修改已有代码，不仅会让这个函数越来越难维护，
还可能因为修改带来一些 bug。所以为了解耦，需要使用策略模式，定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法（即策略）。


// 比如，针对不同的事件等级进行告警，发邮件、发短信、打电话等等
// 这种通过 if … else … 的形式来调用不同的告警方式，称之为硬编码。
func Alert(EventType){
   if EventType == "1"{
      发邮件
   }else if EventType == "2"{
      发短信
   }else if EventType == "3"{
      打电话
  }
}

可以定义策略接口 IStrategy，还定义了 email、message、phone 等告警策略。然后定义了一个策略执行者，可以设置不同的策略，
这时我们可以随意更换策略，而不影响 Operator 的所有实现。

// 策略模式实现
// 定义一个策略类
type IStrategy interface {
	do(EventType)
}
--------------------------
// 策略实现：一、发邮件逻辑
type email struct{}

func (*email) do(EventType)  {
	//发邮件逻辑
}
--------------------------
// 策略实现：二、发短信逻辑
type message struct{}

func (*message) do(EventType) {
	//发短信逻辑
}
--------------------------
// 策略实现：三、打电话逻辑
type phone struct{}

func (*phone) do(EventType) {
	//打电话逻辑
}
--------------------------
// 具体策略的执行者
type Operator struct {
	strategy IStrategy
}

// 设置策略
func (operator *Operator) setStrategy(strategy IStrategy) {
	operator.strategy = strategy
}

// 调用策略中的方法
func (operator *Operator) calculate(EventType) int {
	return operator.strategy.do(EventType)
}

