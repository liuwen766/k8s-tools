- 本项目其他笔记见专栏：[https://blog.csdn.net/hancoder/category_10822407.html](https://blog.csdn.net/hancoder/category_10822407.html)
- 笔记-基础篇-1(P1-P28)：[https://blog.csdn.net/hancoder/article/details/106922139](https://blog.csdn.net/hancoder/article/details/106922139)
- 笔记-基础篇-2(P28-P100)：[https://blog.csdn.net/hancoder/article/details/107612619](https://blog.csdn.net/hancoder/article/details/107612619)
- 笔记-高级篇(P340)：[https://blog.csdn.net/hancoder/article/details/107612746](https://blog.csdn.net/hancoder/article/details/107612746)
- 笔记-vue：[https://blog.csdn.net/hancoder/article/details/107007605](https://blog.csdn.net/hancoder/article/details/107007605)
- 笔记-elastic search、上架、检索：[https://blog.csdn.net/hancoder/article/details/113922398](https://blog.csdn.net/hancoder/article/details/113922398)
- 笔记-认证服务：[https://blog.csdn.net/hancoder/article/details/114242184](https://blog.csdn.net/hancoder/article/details/114242184)
- 笔记-分布式锁与缓存：[https://blog.csdn.net/hancoder/article/details/114004280](https://blog.csdn.net/hancoder/article/details/114004280)
- 笔记-集群篇：[https://blog.csdn.net/hancoder/article/details/107612802](https://blog.csdn.net/hancoder/article/details/107612802)
- springcloud笔记：[https://blog.csdn.net/hancoder/article/details/109063671](https://blog.csdn.net/hancoder/article/details/109063671)
- 笔记版本说明：2020年提供过笔记文档，但只有P1-P50的内容，2021年整理了P340的内容。请点击标题下面分栏查看系列笔记
- 声明：

  - 可以白嫖，但请勿转载发布，笔记手打不易
  - 本系列笔记不断迭代优化，csdn：hancoder上是最新版内容，10W字都是在csdn免费开放观看的。
  - 离线md笔记文件获取方式见文末。2021-3版本的md笔记打完压缩包共500k（云图床），包括本项目笔记，还有cloud、docker、mybatis-plus、rabbitMQ等个人相关笔记
- sql：[https://github.com/FermHan/gulimall/sql文件](https://github.com/FermHan/gulimall/sql文件)



> 本篇2.5W字，请直接ctrl+F搜索内容

## 一、gulimall-cart

构建gulimall-cart，复制静态资源到nginx，修改网关

购物车分为离线购物车和登录购物车

离线购物车重启浏览器了也还有



## 二、购物车

### 1、购物车需求

特点：读多写少，放入数据库并不合适

登录状态：登录购物车

- 放入数据库
- mongodb
- 放入redis（采用）
  - 登录以后，将离线购物车里合并后清空离线购物车

未登录状态：离线购物车

- 放入localstorage浏览器的技术
- cookie
- WebSQL
- 放入redis（采用）
  - 浏览器重启后还在



### 2、购物车VO

在本节中我们会用redis的map存每个用户的购物车内容，key为skuId

接下来我们会在cart项目里创建几个实体类：

- Cart：每个用户的购物车
- CartItem：购物车中每一项sku
- SkuInfoVo：根据sku远程调用product服务返回的sku信息
- UserInfoTo：与购物车关联的用户信息，比如是否是临时购物车

#### (1) 用户购物车redis

购物车

```json
{
    skuid:123123,
    check:true, # 每一项是否被选中
    title:"apple ...",
    defaultImage:"",
    price:4999,
    count:1,
    totalPrice:4999, # 商品的总价=单价*数量
    skuSaleVO:{...}
}
```

购物车不只一条数据

```json
[
    {sku1},{sku2},{}
]
```

redis有5种不同数据结构，这里选择哪一种比较合适呢？每个用户一个map

不好的方式：所有用户同一map，此时购物车key为用户，value是用户的所有购车信息。

但是，我们对购车中的商品进行增、删、改操作，基本都需要根据**商品id**讲行判断，为了方便后期处理，我们的购车也应该是k-v结构，key是**商品id**，value才是这个商品的购车信息。

> 一个购物车是由各个购物项组成的，但是我们用`List`进行存储并不合适，因为使用`List`查找某个购物项时需要挨个遍历每个购物项，会造成大量时间损耗，为保证查找速度，我们使用`hash`进行存储
>
> 每个人都有一个hash表，key为skuId，value为数据

为了后期操作的方便，我们skuId对应的值不应该只有购买数量，而是还应该有选中状态，标题，价格，图片地址，数量等信息。

![](https://i0.hdslb.com/bfs/album/f98a7721050fca818ad911c9458e0cdf96a0d1e4.png)



#### (2) 购物车项vo

P238

![](https://i0.hdslb.com/bfs/album/dc776a77808baab4b5da34d0ea21c20ee2e4f3c9.png)

```java
@Data
public class CartItem {

    private Long skuId;

    /*** 是否被选中*/
    private Boolean check = true;

    private String title;
    private String image;

    private List<String> skuAttr;

    /** 价格、数量、单项总价 */
    private BigDecimal price;
    private Integer count;
    private BigDecimal totalPrice;

    /**
	 * 手动计算sku总价
	 */
    public BigDecimal getTotalPrice() {
        return this.price.multiply(new BigDecimal("" + this.count));
    }
}
```



#### (3) 购物车vo

![](https://i0.hdslb.com/bfs/album/67898cff3579270dea6f6003d82a022bbe753d2b.png)

```java
@Data
public class Cart {

	private List<CartItem> items;

	/*** 商品的数量*/
	private Integer countNum;
	/*** 商品的类型数量*/
	private Integer countType;

	/*** 整个购物车的总价*/
	private BigDecimal totalAmount;

	/*** 减免的价格*/
	private BigDecimal reduce = new BigDecimal("0.00");

	/*** 计算商品的总量*/
	public Integer getCountNum() {
		int count = 0;
		if(this.items != null && this.items.size() > 0){
			for (CartItem item : this.items) {
				count += item.getCount();
			}
		}
		return count;
	}

	public Integer getCountType() {
		int count = 0;
		if(this.items != null && this.items.size() > 0){
			for (CartItem item : this.items) {
				count += 1;
			}
		}
		return count;
	}

	public BigDecimal getTotalAmount() {
		BigDecimal amount = new BigDecimal("0");
		if(this.items != null && this.items.size() > 0){
			for (CartItem item : this.items) {
				if(item.getCheck()){
					BigDecimal totalPrice = item.getTotalPrice();
					amount = amount.add(totalPrice);
				}
			}
		}
		return amount.subtract(this.getReduce());
	}
}
```

> ps：debug项目会让nacos注册的微服务丢失心跳

### 3、 ThreadLocal用户身份鉴别

#### (1) threadlocal说明

threadlocal的效果是其中存储的内容只有当前线程能访问的

> 如果想了解更多threadlocal知识可以查看：[https://blog.csdn.net/hancoder/article/details/107853513](https://blog.csdn.net/hancoder/article/details/107853513)
>
> threadlocal的原理是每个线程都有一个map，key为threadlocal对象，value为对象所对应的值

参考京东，在点击购物车时，会为**临时用户**生成一个`name`为`user-key`的`cookie`临时标识，过期时间为一个月，如果手动清除`user-key`，那么临时购物车的购物项也被清除，所以`user-key`是用来标识和存储临时购物车数据的

#### (2) 使用ThreadLocal进行用户身份鉴别信息传递

但是注意的是tomcat中线程可以复用，所以线程和会话不是一对一的关系。但是没有关系，会在拦截器中先判断会话有没有用户信息（cookie），

- 首先明确每次拦截器都会重新设置threadlocal
- 没有的话创建一个临时用户，回去的时候告诉用户的临时cookie。
- 有的话把临时用户和登录用户封装到一起，设置到threadlocal中
- 如果登录了，处理完临时用户信息后，把临时购物车的内容删掉，或者标识为非临时用户，防止多次重复临时数据

> 因为有线程池复用的关系，上面解释了下一次开始使用线程时会自己设置用户信息到threadlocal，但你有没有想过线程会不会切换？我们知道cpu会切换，线程呢？NIO中，拿到socket后注册到selector中，当有事件时，拿到线程池中去执行。对此我的解释是：socket可以长链接，但是拿到线程池中这个操作是不间断的，也就是一次请求完整执行一次，线程不变（cpu切换无所谓）。

##### ==拦截器==注入

购物车拦截器的配置

```java
@Configuration
public class GulimallWebConfig implements WebMvcConfigurer {
    //拦截所有请求
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new CartInterceptor()).addPathPatterns("/**");
    }
}
```

购物车==拦截器==：此时也解决临时购物车的问题

- 可以看到有句session.getAttribute(AuthServerConstant.LOGIN_USER);获取登录用户
- 看cookie中有没有临时数据，就是cookie带过来的
- 将用户信息放到threadlocal中让当前用户使用threadLocal.set(userInfoTo);

```java
public class CartInterceptor implements HandlerInterceptor {

	// 存放当前线程用户信息
	public static ThreadLocal<UserInfoTo> threadLocal = new ThreadLocal<>();

	/** userInfoTo包含登录用户和临时用户的信息*/
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

		// 准备好要设置到threadlocal里的user对象
		UserInfoTo userInfoTo = new UserInfoTo();
		HttpSession session = request.getSession();
		// 获取loginUser对应的用户value，没有也不去登录了。登录逻辑放到别的代码里，需要登录时再重定向
		MemberRespVo user = (MemberRespVo) session.getAttribute(AuthServerConstant.LOGIN_USER);
		// 已登录用户，设置userId
		if (user != null){
			userInfoTo.setUsername(user.getUsername());
			userInfoTo.setUserId(user.getId());//明确下登录用的是UserId，临时用户用的是UserKey
		}

		// 将cookie中的临时购物车信息设置到threadlocal中 // 不登录也没关系，可以访问临时用户购物车
		Cookie[] cookies = request.getCookies();
		if( cookies != null && cookies.length > 0){
			for (Cookie cookie : cookies) {
				String name = cookie.getName();
				if(CartConstant.TEMP_USER_COOKIE_NAME.equals(name)){ // 有"user-key";这个cookie
					userInfoTo.setUserKey(cookie.getValue());
					userInfoTo.setTempUser(true);
				}
			}
		}
		// 如果没有临时用户和登录用户，则分配一个临时用户 // 分配的临时用户在postHandle的时候放到cookie里即可
		if (StringUtils.isEmpty(userInfoTo.getUserKey())  // 没有临时用户时
				&& StringUtils.isEmpty(userInfoTo.getUserId())){ // 有登录用户就不生成临时
			String uuid = UUID.randomUUID().toString().replace("-","");
			userInfoTo.setUserKey("GULI-" + uuid);//临时用户
		}
		threadLocal.set(userInfoTo);
		return true;
		// 还有一个登录后应该删除临时购物车的逻辑没有实现
	}

	/**
	 * 执行完毕之后分配临时用户让浏览器保存
	 */
	@Override
	public void postHandle(HttpServletRequest request,
						   HttpServletResponse response, Object handler,
						   ModelAndView modelAndView) throws Exception {

		UserInfoTo userInfoTo = threadLocal.get();
		// 如果是临时用户，返回临时购物车的cookie
		if(!userInfoTo.isTempUser()){
			Cookie cookie = new Cookie(CartConstant.TEMP_USER_COOKIE_NAME, userInfoTo.getUserKey());
			// 设置cookie作用域、过期时间
			cookie.setDomain("gulimall.com");
			cookie.setMaxAge(CartConstant.TEMP_USER_COOKIE_TIME_OUT);
			response.addCookie(cookie);
		}
	}
}
```



### 3. 添加商品到购物车

> 需要的服务：gateway、product、ware、cart、seckill、search、auth我隔了好久再启动时候，也会忘记从哪加入购物车。最后选择从搜索栏里加入购物车，还需要注意的是你最好去renren后台里搜索一下商品管理里的内容，否则很容易搜到ES中的假数据

用户在一个商品页面点击sku，点击后

> 商品详情页需要启动auth、seckill服务

```java
/*** 添加商品到购物车
	 *  RedirectAttributes.addFlashAttribute():将数据放在session中，可以在页面中取出，但是只能取一次
	 *  RedirectAttributes.addAttribute():将数据拼接在url后面，?skuId=xxx
	 * */
@GetMapping("/addToCart")
public String addToCart(@RequestParam("skuId") Long skuId,
                        @RequestParam("num") Integer num,
                        RedirectAttributes redirectAttributes)  // 重定向数据， 会自动将数据添加到url后面
    throws ExecutionException, InterruptedException {

    // 添加数量到用户购物车
    cartService.addToCart(skuId, num);
    // 返回skuId告诉哪个添加成功了
    redirectAttributes.addAttribute("skuId", skuId);
    // 重定向到成功页面，使用重定向防止重复提交表单
    return "redirect:http://cart.gulimall.com/addToCartSuccess.html";
}

// 添加sku到购物车响应页面
@GetMapping("/addToCartSuccess.html")
public String addToCartSuccessPage(@RequestParam(value = "skuId",required = false) Object skuId, Model model){
    CartItem cartItem = null;
    // 然后在查一遍 购物车
    if(skuId == null){
        model.addAttribute("item", null);
    }else{
        try {
            cartItem = cartService.getCartItem(Long.parseLong((String)skuId));
        } catch (NumberFormatException e) {
            log.warn("恶意操作! 页面传来skuId格式错误");
        }
        model.addAttribute("item", cartItem);
    }
    return "success";
}
```

##### 获取用户购物车数据

先获取redis里该用户购物车的那个map，**每个用户的购物车都是个map**，map名为`ATGUIGU:cart:用户id`

登录用户优先

```java
private BoundHashOperations<String, Object, Object> getCartOps() {
    // 1. 这里我们需要知道操作的是离线购物车还是在线购物车
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
  
    String cartKey = CART_PREFIX; //  "ATGUIGU:cart:";
    if(userInfoTo.getUserId() != null){
        log.debug("\n用户 [" + userInfoTo.getUsername() + "] 正在操作购物车");
        // 已登录的用户购物车的标识
        cartKey += userInfoTo.getUserId();
    }else{
        log.debug("\n临时用户 [" + userInfoTo.getUserKey() + "] 正在操作购物车");
        // 未登录的用户购物车的标识
        cartKey += userInfoTo.getUserKey();
    }
    // 绑定这个 key 以后所有对redis 的操作都是针对这个key
    return stringRedisTemplate.boundHashOps(cartKey);
}
```

比如上面获取了登录用户的购物车，但是临时信息还没合并

##### 购物车service

* 若购物车中已经存在该商品，只需增添数量
* 否则需要查询商品购物项所需信息，并添加新商品至购物车
  * map的key是skuId，value是数量

```java
@Override // CartServiceImpl
public CartItem addToCart(Long skuId, Integer num) throws ExecutionException, InterruptedException {
    // 获取当前用户的map
    BoundHashOperations<String, Object, Object> cartOps = getCartOps();
    // 查看该用户购物车里是否有指定的skuId
    String res = (String) cartOps.get(skuId.toString());

    // 查看用户购物车里是否已经有了该sku项
    if(StringUtils.isEmpty(res)){
        CartItem cartItem = new CartItem();
        // 异步编排
        CompletableFuture<Void> getSkuInfo = CompletableFuture.runAsync(() -> {
            // 1. 远程查询当前要添加的商品的信息
            R skuInfo = productFeignService.SkuInfo(skuId);
            SkuInfoVo sku = skuInfo.getData("skuInfo", new TypeReference<SkuInfoVo>() {});
            // 2. 填充购物项
            cartItem.setCount(num);
            cartItem.setCheck(true);
            cartItem.setImage(sku.getSkuDefaultImg());
            cartItem.setPrice(sku.getPrice());
            cartItem.setTitle(sku.getSkuTitle());
            cartItem.setSkuId(skuId);
        }, executor);

        // 3. 远程查询sku销售属性，销售属性是个list
        CompletableFuture<Void> getSkuSaleAttrValues = CompletableFuture.runAsync(() -> {
            List<String> values = productFeignService.getSkuSaleAttrValues(skuId);
            cartItem.setSkuAttr(values);
        }, executor);
        // 等待执行完成
        CompletableFuture.allOf(getSkuInfo, getSkuSaleAttrValues).get();

        // sku放到用户购物车redis中
        cartOps.put(skuId.toString(), JSON.toJSONString(cartItem));
        return cartItem;
    }else{//购物车里已经有该sku了，数量+1即可
        CartItem cartItem = JSON.parseObject(res, CartItem.class);
        // 不太可能并发，无需加锁
        cartItem.setCount(cartItem.getCount() + num);
        cartOps.put(skuId.toString(), JSON.toJSONString(cartItem));
        return cartItem;
    }
}
```

### 4. 展示购物车与合并临时数据

* 若用户未登录，则直接使用`user-key`获取购物车数据
* 否则使用`userId`获取购物车数据，并将`user-key`对应临时购物车数据与用户购物车数据合并，并删除临时购物车

```java
@RequestMapping("/cart.html")
public String getCartList(Model model) {
    CartVo cartVo=cartService.getCart();
    model.addAttribute("cart", cartVo);
    return "cartList";
}


@Override
public Cart getCart() throws ExecutionException, InterruptedException {
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    Cart cart = new Cart();
    // 临时购物车的key
    String tempCartKey = CART_PREFIX + userInfoTo.getUserKey();
    // 是否登录
    if(userInfoTo.getUserId() != null){
        // 已登录 对用户的购物车进行操作
        String cartKey = CART_PREFIX + userInfoTo.getUserId();
        
        // 1 如果临时购物车的数据没有进行合并
        List<CartItem> tempItem = getCartItems(tempCartKey);
        
        if(tempItem != null){
            // 2 临时购物车有数据 则进行合并
            log.info("\n[" + userInfoTo.getUsername() + "] 的购物车已合并");
            for (CartItem cartItem : tempItem) {
                addToCart(cartItem.getSkuId(), cartItem.getCount());
            }
            
            // 3 清空临时购物车,防止重复添加
            clearCart(tempCartKey);
            
            // 设置为非临时用户
            userInfoTo.setTempUser(false);
        }
        // 4 获取登录后的购物车数据 [包含合并过来的临时购物车数据]
        List<CartItem> cartItems = getCartItems(cartKey);
        cart.setItems(cartItems);
    }else {
        // 没登录 获取临时购物车的所有购物项
        cart.setItems(getCartItems(tempCartKey));
    }
    return cart;
}

/**
	 * 获取购物车所有项
	 */
private List<CartItem> getCartItems(String cartKey){
    BoundHashOperations<String, Object, Object> hashOps = stringRedisTemplate.boundHashOps(cartKey);
    // key不重要，拿到值即可
    List<Object> values = hashOps.values();
    if(values != null && values.size() > 0){
        return values.stream().map(obj -> JSON.parseObject(JSON.toJSONString(obj) , CartItem.class)).collect(Collectors.toList());
    }
    return null;
}
```

### 5. 选中购物车项

更改购物项sku选中状态

```java
@RequestMapping("/checkCart")
public String checkCart(@RequestParam("isChecked") Integer isChecked,@RequestParam("skuId")Long skuId) {
    cartService.checkItem(skuId, isChecked);
    return "redirect:http://cart.gulimall.com/cart.html";
}

//修改skuId对应购物车项的选中状态
@Override
public void checkItem(Long skuId, Integer check) {
    // 获取要选中的购物项 // 信息还是在原来的缓存中，更新即可
    CartItem cartItem = getCartItem(skuId);
    cartItem.setCheck(check==1?true:false);
    BoundHashOperations<String, Object, Object> cartOps = getCartOps();
    cartOps.put(skuId.toString(), JSON.toJSONString(cartItem));
}

@Override
public CartItem getCartItem(Long skuId) {
    BoundHashOperations<String, Object, Object> cartOps = getCartOps();
    String o = (String) cartOps.get(skuId.toString());
    return JSON.parseObject(o, CartItem.class);
}
```

### 6. 修改购物项数量

```java
@RequestMapping("/countItem")
public String changeItemCount(@RequestParam("skuId") Long skuId, @RequestParam("num") Integer num) {
    cartService.changeItemCount(skuId, num);
    return "redirect:http://cart.gulimall.com/cart.html";
}

@Override
public void changeItemCount(Long skuId, Integer num) {
    BoundHashOperations<String, Object, Object> ops = getCartItemOps();
    String cartJson = (String) ops.get(skuId.toString());
    CartItemVo cartItemVo = JSON.parseObject(cartJson, CartItemVo.class);
    cartItemVo.setCount(num);
    ops.put(skuId.toString(),JSON.toJSONString(cartItemVo));
}
```

### 7. 删除购物车项

```java
@RequestMapping("/deleteItem")
public String deleteItem(@RequestParam("skuId") Long skuId) {
    cartService.deleteItem(skuId);
    return "redirect:http://cart.gulimall.com/cart.html";
}

@Override
public void deleteItem(Long skuId) {
    BoundHashOperations<String, Object, Object> ops = getCartItemOps();
    ops.delete(skuId.toString());
}
```

## 三、消息队列

https://blog.csdn.net/hancoder/article/details/114297652

## 四、Session共享

这部分的内容请去认证服务笔记里看[https://blog.csdn.net/hancoder/article/details/114242184](https://blog.csdn.net/hancoder/article/details/114242184)

思想就是用redis存储session，并且cookie的作用域跨大到*.gulimall.com

如果域名不同可以用单点登录解决，思想为创建登录服务器，去登录服务器获取用户的redis-key，然后在自己的服务里请求redis对应的用户后保存到自己的session里

## ==五、订单模型==

资料源码中等待付款是订单详情页；订单页是用户订单列表；结算页是订单确认页；收银页是支付页cd

在nginx中新建目录order

- 放到IDEA-order项目中
- `order/detail`中放入【等待付款】的静态资源。index.html重命名为`detail.html`
- `order/list`中放入【订单页】的静态资源。index.html重命名为`list.html`
- `order/confirm`中放入【结算页】的静态资源。index.html重命名为`confirm.html`
- `order/pay`中放入【收银页】的静态资源。index.html重命名为`pay.html`
- 修改HOSTS，`192.168.56.10 order.gulimall.com`
- nginx中已经配置过转发
- 在gateway中新增order路由
- 修改html中的路径/static前缀。比如`/static/order/confirm`
- 注意一下有的同学在@GetMapping("/memverOrder.html")里的参数没有匹配好，第一个参数可以直接定义为String
- 注意一下看看数据库里用户和订单表的对应情况，你登录该用户才能看到他的订单



#### 订单概念

订单中心：

电商系统涉及到3流，分别是**信息流，资金流，物流**，而订单系统作为中枢将三者有机的集合起来。

订单模块是电商系统的枢纽，在订单这个环节上需求获取多个模块的数据和信息，同时对这些信息进行加工处理后流向下个环节，这一系列就构成了订单的信息流通。

![img](https://pic2.zhimg.com/80/v2-535e69f5126dbf5be48db1dae18d5a09_1440w.jpg)

#### 订单状态

- 1) 待付款

用户提交订单后，订单进行预下单，目前主流电商网站都会唤起支付，便于用户快速完成支付，需要汪意的是待付款状态下可以对库存进行锁定，锁定库存需要配置支付超时时间，超时后将自动取消订单，订单变更关闭状态。

- 2) 已付款/待发货

用户完成订单支付，订单系统需要记录支付时间，支付流水单号便于对账，订单下放到WMS系统，仓库进行调拨，配货，分拣，出库等操作。

- 3) 待收货/已发货

仓储将商品出库后，订单进入物流环节，订单系统需要同步物流信息，便于用户实时知悉物品物流状态

- 4) 已完成
  用户确认收货后，订单交易完成。后续支付亻则进行结算，如果订单存在间题进入售后状态

- 5) 已取消

付款之前取消订单。包括超时未付款或用户商户取消订单都会产生这种订单状态。

- 6) 售后中

用户在付款后申请退款，或商家发货后用户申请退换货。

售后也同样存在各种状态，

- 当发起售后申请后生成售后订单，
- 售后订单状态为待审核，等待商家审核，
- 商家审核过后订单状态变更为待退货，等待用户将商品机会，
- 商家收到货后订单
  

#### 订单流程

订单流程是指从订单产生到完成整个流转的过程，从而行程了一套标准流程规则。而不同的产品类型或业务类型在系统中的流程会千差万别，比如上面提到的线上实物订单和虚拟订单的流程，线上实物订单与O2O订单等，所以需要根据不同的类型进行构建订单流程。

不管类型如何订单都包括正向流程和逆向流程，对应的场景就是购买商品和退换货流程，正向流程就是一个正常的网购步骤：

订单生成一>支付订单一>卖家发货一>确认收货一>交易成功。

而每个步骤的背后，订单是如何在多系统之间交互流转的，可概括如下图

<img src="https://i0.hdslb.com/bfs/album/ea28cc51e0766ed9a83f2207d50d74a02efe8f0d.png" style="zoom:38%;" />

![img](https://pic2.zhimg.com/80/v2-beaa439404df862953c0406670c9eedd_1440w.jpg)

## 六、服务通信数据共享问题

### 订单登录拦截

因为订单系统必然涉及到用户信息，因此进入订单系统的请求必须是已经登录的，所以我们需要通过拦截器对未登录订单请求进行拦截

- 先注入拦截器HandlerInterceptor组件
- 在config中实现`WebMvcConfigurer接口.addInterceptor()`方法
- 拦截器和认证器的关系我在前面认证模块讲过，可以翻看，这里不赘述了

```java

@Component
public class LoginUserInterceptor implements HandlerInterceptor {

	public static ThreadLocal<MemberRespVo> threadLocal = new ThreadLocal<>();

	@Override
	public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) throws Exception {

		String uri = request.getRequestURI();
		// 这个请求直接放行
		boolean match = new AntPathMatcher().match("/order/order/status/**", uri);
		if(match){
			return true;
		}
		// 获取session
		HttpSession session = request.getSession();
		// 获取登录用户
		MemberRespVo memberRespVo = (MemberRespVo) session.getAttribute(AuthServerConstant.LOGIN_USER);
		if(memberRespVo != null){
			threadLocal.set(memberRespVo);
			return true;
		}else{
			// 没登陆就去登录
			session.setAttribute("msg", AuthServerConstant.NOT_LOGIN);
			response.sendRedirect("http://auth.gulimall.com/login.html");
			return false;
		}
	}
}
```

```JAVA
@Configuration
public class GulimallWebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor()).addPathPatterns("/**");
    }
}
```

加上ThreadLocal共享数据，是为了登录后把用户放到本地内存，而不是每次都去远程session里查

在auth-server中登录成功后会把会话设置到session中

```java
MemberRespVo data = login.getData("data",new TypeReference<MemberRespVo>);
session.setAttribute(AuthServerConstant.LOGIN_USER,data);
```

### 异步线程的request数据与远程调用cookie的携带

#### 1) RequestContextHolder

RequestContextHolder可以解决的问题：

- 正常来说在service层是没有request和response的，然而直接从controlller传过来的话解决方法太粗暴。解决方法是SpringMVC提供的`RequestContextHolder`
- 用线程池执行任务时非主线程是没有请求数据的，可以通过该方法设置线程中的request数据，原理还是用的threadlocal（此时就要注意new thread就获取不到请求了）

RequestContextHolder推荐阅读：https://blog.csdn.net/asdfsadfasdfsa/article/details/79158459

在spring mvc中，为了随时都能取到当前请求的request对象，可以通过`RequestContextHolder`的静态方法`getRequestAttributes()`获取Request相关的变量，如request，response等

RequestContextHolder顾名思义，持有上下文的Request容器。

下面代码的逻辑是拿到当前请求数据，拿到name数据对应的值，

```java
//两个方法在没有使用JSF的项目中是没有区别的
RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();
//                                    RequestContextHolder.getRequestAttributes();
//从session里面获取对应的值
String str = (String) requestAttributes.getAttribute("name",RequestAttributes.SCOPE_SESSION);
// 拿到请求
HttpServletRequest  request  = ((ServletRequestAttributes)requestAttributes).getRequest();
// 响应
HttpServletResponse response = ((ServletRequestAttributes)requestAttributes).getResponse();
```

原理：那么是什么时候把request和response设置进去的呢？mvc的service()方法里有`processRequest(request, response);`，每个请求来了都会执行，

1. 获取上一个请求的参数
2. 重新建立新的参数
3. 设置到XXContextHolder
4. 父类的service()处理请求
5. 恢复request
6. 发布事件



#### 2）rpc丢失用户信息

`feign`远程调用的请求头中没有含有`JSESSIONID`的`cookie`，所以也就不能得到服务端的`session`数据，也就没有用户数据，cart认为没登录，获取不了用户信息

![](https://i0.hdslb.com/bfs/album/20b66cdfda93c22c3e817232f1fb90b484a2517e.png)



我们追踪**远程调用的源码**，可以在SynchronousMethodHandler.targetRequest()方法中看到他会遍历容器中的`RequestInterceptor`进行封装，所以我们看哪里能注入到ac里RequestInterceptor，然后给rpc带上cookie

```java
Request targetRequest(RequestTemplate template) {
  for (RequestInterceptor interceptor : requestInterceptors) {
    interceptor.apply(template);
  }
  return target.apply(template);
}
```

但是在`feign`的调用过程中，会使用容器中的`RequestInterceptor`对`RequestTemplate`进行处理，因此我们可以通过向容器中导入定制的`RequestInterceptor`为请求加上`cookie`。

```java
public class GuliFeignConfig {
    @Bean
    public RequestInterceptor requestInterceptor() {
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate template) {
                //1. 使用RequestContextHolder拿到老请求的请求数据
                ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                if (requestAttributes != null) {
                    HttpServletRequest request = requestAttributes.getRequest();
                    if (request != null) {
                        //2. 将老请求得到cookie信息放到feign请求上
                        String cookie = request.getHeader("Cookie");
                        template.header("Cookie", cookie);
                    }
                }
            }
        };
    }
}
```

注意：上面在封装cookie的时候要拿到原来请求的`cookie`，设置到新的请求中

`RequestContextHolder`为SpingMVC中共享`request`数据的上下文，底层由`ThreadLocal`实现，也就是说该请求只对当前访问线程有效，如果new了新线程就找不到原来request了

#### 3）线程异步丢失上下文问题

P268

因为异步编排的原因，他会丢掉`ThreadLocal`中原来线程的数据，从而获取不到`loginUser`，这种情况下我们可以在方法内的局部变量中先保存原来线程的信息，在异步编排的新线程中拿着局部变量的值重新设置到新线程中即可。

> 由于`RequestContextHolder`使用`ThreadLocal`共享数据，所以在开启异步时获取不到老请求的信息，自然也就无法共享`cookie`了

![](https://i0.hdslb.com/bfs/album/110343bb0df6db2c6c3b26b64f24bb6329c2e53c.png)

在这种情况下，我们需要在开启异步的时候将老请求的`RequestContextHolder`的数据设置进去

OrderServiceImpl.confirmOrder()代码

```java
// 从主线程获取用户数据 放到局部变量中
RequestAttributes attributes = RequestContextHolder.getRequestAttributes();
CompletableFuture<Void> getAddressFuture = CompletableFuture.runAsync(() -> {
    // 把旧RequestAttributes放到新线程的RequestContextHolder中
    RequestContextHolder.setRequestAttributes(attributes);
    // 远程查询所有的收获地址列表
    List<MemberAddressVo> address;
    try {
        address = memberFeignService.getAddress(MemberRespVo.getId());
```

此外远程获取价格的时候应该用R

## 七、订单确认页

#### 1）订单确认页VO

点击"去结算"就会跳到订单确认页

- 展示当前用户收获地址list
- 所有选中的购物项list
- 支付方式
- 送货清单，价格也是最新价格，不是加入购物车时的价格
- 优惠信息

<img src="https://i0.hdslb.com/bfs/album/057b3bb84db2f90e72c5dbe56b03d1fc11d9805f.png" style="zoom: 33%;" />

跳转到确认页时需要携带的数据模型。

- 要注意生成订单的时候，价格得重新算
- 在后面的修改中，会让提交订单时不带着购物车数据，而是在后台重新 查询购物车选项。
- 会带着总价，比对新总价和就总价是否一致

```java
public class OrderConfirmVo { // 跳转到确认页时需要携带的数据模型。

    @Getter
    @Setter
    /** 会员收获地址列表 **/
    private List<MemberAddressVo> memberAddressVos;

    @Getter @Setter
    /** 所有选中的购物项 **/
    private List<OrderItemVo> items;

    /** 发票记录 **/
    @Getter @Setter
    /** 优惠券（会员积分） **/
    private Integer integration;

    /** 防止重复提交的令牌 **/
    @Getter @Setter
    private String orderToken;

    @Getter @Setter
    Map<Long,Boolean> stocks;

    public Integer getCount() { // 总件数
        Integer count = 0;
        if (items != null && items.size() > 0) {
            for (OrderItemVo item : items) {
                count += item.getCount();
            }
        }
        return count;
    }


    /** 计算订单总额**/
    //BigDecimal total;
    public BigDecimal getTotal() { 
        BigDecimal totalNum = BigDecimal.ZERO;
        if (items != null && items.size() > 0) {
            for (OrderItemVo item : items) {
                //计算当前商品的总价格
                BigDecimal itemPrice = item.getPrice().multiply(new BigDecimal(item.getCount().toString()));
                //再计算全部商品的总价格
                totalNum = totalNum.add(itemPrice);
            }
        }
        return totalNum;
    }


    /** 应付价格 **/
    //BigDecimal payPrice;
    public BigDecimal getPayPrice() {
        return getTotal();
    }
}
```

#### 2）订单确认页数据获取

* 异步：查询购物项（redis）、库存和收货地址（数据库）都要调用远程服务，串行会浪费大量时间，因此我们使用`CompletableFuture`进行异步编排
* 为了防止多次重复点击“订单提交按钮”。我们在**返回订单确认页**时，在`redis`中生成一个随机的令牌，过期时间为30min，**提交订单时**会携带这个令牌，我们将会在订单提交的处理页面核验此令牌，确认后删除掉防止重复提交。

在购物车页面点击去结算，点击事件是`window.location.href = "http://order.gulimall.com/toTrade";`

##### 返回订单确认页

```java
// Order服务里的controller
@RequestMapping("/toTrade") // 用于返回订单确认页
public String toTrade(Model model) {
    // 内容是从登录用户里获取，所以不用带过来
    OrderConfirmVo confirmVo = orderService.confirmOrder();
    // 订单确认页要显示的数据
    model.addAttribute("confirmOrder", confirmVo);
    return "confirm";
}
```

返回信息：

<img src="https://i0.hdslb.com/bfs/album/057b3bb84db2f90e72c5dbe56b03d1fc11d9805f.png" style="zoom: 33%;" />

利用CompletableFuture异步获取各项数据

```java
@Override // OrderServiceImpl // 返回信息
public OrderConfirmVo confirmOrder() throws ExecutionException, InterruptedException {
    // 获取用户，用用户信息获取购物车
    MemberRespVo MemberRespVo = LoginUserInterceptor.threadLocal.get();
    // 封装订单
    OrderConfirmVo confirmVo = new OrderConfirmVo();

    // 我们要从request里获取用户数据，但是其他线程是没有这个信息的，
    // 所以可以手动设置新线程里也能共享当前的request数据
    RequestAttributes attributes = RequestContextHolder.getRequestAttributes();

    // 1.远程查询所有的收获地址列表
    CompletableFuture<Void> getAddressFuture = CompletableFuture.runAsync(() -> {
        // 因为异步线程需要新的线程，而新的线程里没有request数据，所以我们自己设置进去
        RequestContextHolder.setRequestAttributes(attributes);

        List<MemberAddressVo> address;
        try {
            address = memberFeignService.getAddress(MemberRespVo.getId());
            confirmVo.setAddress(address);
        } catch (Exception e) {
            log.warn("\n远程调用会员服务失败 [会员服务可能未启动]");
        }
    }, executor);

    // 2. 远程查询购物车服务，并得到每个购物项是否有库存
    CompletableFuture<Void> cartFuture = CompletableFuture.runAsync(() -> {
        // 异步线程共享 RequestContextHolder.getRequestAttributes()
        RequestContextHolder.setRequestAttributes(attributes);

        // feign在远程调用之前要构造请求 调用很多拦截器
        // 远程获取用户的购物项
        List<OrderItemVo> items = cartFeignService.getCurrentUserCartItems();
        confirmVo.setItems(items);
    }, executor).thenRunAsync(() -> {
        RequestContextHolder.setRequestAttributes(attributes);
        List<OrderItemVo> items = confirmVo.getItems();
        // 获取所有商品的id
        List<Long> skus = items.stream().map(item -> item.getSkuId()).collect(Collectors.toList());
        R hasStock = wmsFeignService.getSkuHasStock(skus);
        List<SkuStockVo> data = hasStock.getData(new TypeReference<List<SkuStockVo>>() {});
        if (data != null) {
            // 各个商品id 与 他们库存状态的映射map // 学习下收集成map的用法
            Map<Long, Boolean> stocks = data.stream().collect(Collectors.toMap(SkuStockVo::getSkuId, SkuStockVo::getHasStock));
            confirmVo.setStocks(stocks);
        }
    }, executor);

    // 3.查询用户积分
    Integer integration = MemberRespVo.getIntegration();
    confirmVo.setIntegration(integration);

    // 4.其他数据在类内部自动计算

    // TODO 5.防重令牌 设置用户的令牌
    String token = UUID.randomUUID().toString().replace("-", "");
    confirmVo.setOrderToken(token);
    // redis中添加用户id，这个设置可以防止订单重复提交。生成完一次订单后删除redis
    stringRedisTemplate.opsForValue().set(OrderConstant.USER_ORDER_TOKEN_PREFIX + MemberRespVo.getId(),
                                          token, 10, TimeUnit.MINUTES);
    
    // 等待所有异步任务完成
    CompletableFuture.allOf(getAddressFuture, cartFuture).get();
    return confirmVo;
}
```

##### ==防重令牌==

上面我们返回数据的时候使用了uuid生成了一个防重令牌，他的作用有很多。比如防止用户点击多次提交订单按钮（保证幂等性）。

另外你可以百度下`OSRF`攻击漏洞，这个问题我被面试问过很多回，基本上回答出一个随机码token就得分了。key是用户id或者订单id看情况而定

验证token的lua脚本为：

```java
if redis.call('get',KEYS[1])==ARGV[1]
then return redis.call('del',KEYS[1])
else return 0
end
```



#### 3）运费收件信息获取

- 启动库存服务

- 遍历地址进行显示，收货信息在member-recerve-address表中

- 选中地址后形成订单时该地址

- 有货无货状态，每个商品单独查比较麻烦，可以用skuId-list异步调用库存系统查出来

- 加上运费，并且切换地址时要重新计算运费、总额

- 如何高亮指定的地址border边界框：。主要说明的是th的赋值属性的方法``th:attr="def=${addr.defaultStatus}"`和jquery赋值属性的方法`$(this).attr("def","1");`

- 点击提交订单时计算总额，而不是用当前页面的值，或者比对一下值，不一致让用户重新看订单

  ```html
  <!--地址-->
  <div class="top-3 addr-item" th:each="addr : ${orderConfirmData.address}">
      <p th:attr="def=${addr.defaultStatus},addrId=${addr.id}">[[${addr.name}]]
      </p>
      <span>
          [[${addr.name}]] [[${addr.detailAddress}]]  [[${addr.phone}]]
      </span>
  </div>
  ```

  ```js
  function highlight() {
      // 默认颜色是灰色
      $(".addr-item p").css({"border":"2px solid gray"})
      $(".addr-item p[def='1']").css({"border":"2px solid red"})
  }
  
  $(".addr-item p").click(function () {
      $("a.addr-item p").attr("def","0");// 设置属性
      $(this).attr("def","1");
      highlight();
      // 选择发生了变化就要获取当前地址id
      var addrId = $(this).attr("addrId");
      // 发送Ajax请求获取运费信息
      getFare(addrId)
  });
  ```

  


数据封装

```java
@Data
public class FareVo { // 邮费
    private MemberAddressVo address;
    private BigDecimal fare;
}
```

在页面将选中地址的id传给请求。

获取邮费

```java
@RequestMapping("/fare/{addrId}")
public FareVo getFare(@PathVariable("addrId") Long addrId) {
    return wareInfoService.getFare(addrId);
}

@Override
public FareVo getFare(Long addrId) {
    FareVo fareVo = new FareVo();
    R info = memberFeignService.info(addrId);
    if (info.getCode() == 0) {
        MemberAddressVo address = info.getData("memberReceiveAddress", new TypeReference<MemberAddressVo>() {
        });
        fareVo.setAddress(address);
        String phone = address.getPhone();
        //取电话号的最后两位作为邮费
        String fare = phone.substring(phone.length() - 2, phone.length());
        fareVo.setFare(new BigDecimal(fare));
    }
    return fareVo;
}
```

## ==八、接口幂等性讨论==

P274

讨论：多次点击 【提交订单】 按钮

幂等性：订单提交一次和提交多次结果是一致的

哪些情况要防止：

- 用户多次点击按钮
- 用户页面回退再次提交
- 服务相互调用，由于网络间题，导致请求失败。**feign触发重试机制**
- 其他业务情况

以SQL为例，有些操作是天然原子的。

- ```mysql
  SELECT FROM table WHERE id=? -- 无论执行多少次都不会改变状态，是天然的幂等
  UPDATE table SET col1=1 WHERE col2=2 -- 无论执行成功多少次状态都是一致的，也是幂等操作。
  delete from user where userid=l -- 多次操作，结果一样，具备幂等性
  insert into user (useridname) values(l,'a') -- 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。
  ```

- ```mysql
  UPDATE table1 SET col=col+1 where col2= 22 -- 每执行的結果都会发生变化，不是幂等的。
  insert into user(userId,name)values(1,'a') -- 如userid不是主键，可以重复，那上面业务多次操作，都会新增多条，不具备幂等性
  ```

#### 幂等解决方案

##### (1)、token机制

如12306选中座位后提交，带上验证码与后台该token对应的验证码一致才通过。如果通过了就删除，第二个即使带着验证码也匹配不到

> 前面我们返回订单页面时也在redis中设置了用户的uuid

- 服务端提供了发送token的接囗。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。

- 然后调用业务接囗请求时，把token携带过去，一般放在请求头部。

- 服务器判断token是否存在redis中，存在表示第一次请求，然后==先删除token==，继续执行业务。

  - 但要保证只能有一个去redis看，否则就可能都看到redis中有，删除两次。即【对比+删除】得是原子性的，所以就想到了用`redis-luna`脚本分布式锁

  - ```bash
  if redis.call('get',KEYS[1])==ARGV[1]
    then return redis.call('del',KEYS[1])
    else return 0
    end
    ```
  
- 如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不重复执行。

##### (2)、各种锁

a、数据库悲观锁

> `select * from ×× where id=1 for update;`
> 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。
> 另外要注意的是，id字段一定是主键或者唯一幸引，不然可能造成锁表的结果，处理起来会非常麻烦。

b、数据库乐观锁

> 这种方法适合在更新的场景中，
> `updatet _goods set count=count-1，version=version+1 where good_id=2 and version=1`
>
> 根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了间题，订单服务又一次发起调用库存，服务，当订单服务传如的version还是1，再执行上面的四!v语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。
>
> 乐观锁主要使用于处理读多写少的问题

c、业务层分布式锁

##### (3)、各种唯一约束

a、数据库唯一约束

> 插入数据，应该按照**唯一索引**进行插入，比如订单号，相同的订单就不可能有两条记录插入。
> 我们在数据库层面防止重复。
> 这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主，这样就需要业务生成全局唯一的主键。
> 如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。

b、redis set防重

> 很多数据需要处理，只能被处理一次，比如我们可以计算数据的MD5将其放入redis的set，每次处理数据，先看这个MD5是否已经存在，存在就不处理。

##### (4)、防重表

使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。

之前说的redis防重也算

##### (5)、全局请求唯一id

调用接口时，生成一个唯一id，redis将数据保存到集合（去重），存在即处理过。

可以使用nginx设置每一个请求的唯一id

`proxy_set_header X-Request-id $request_id;`



## 九、订单提交

根据前面的幂等性知识，我们这里用token令牌机制解决幂等性

- 准备好订单确认数据后，返回给用户看运费等信息，同时创建防重令牌`redis.set('order:token:(userId)',uuid)`
  - 也就是给服务器一个，给用户一个
- 用户点击提交订单按钮，带着token。怎么带？设置个hidden元素带着就行
- 渲染订单确认页，后台处理的时候确认请求带过来token的uuid和redis库中是否一致
  - 此处是重点，**比对后立刻删除**，**比对和删除要求具有原子性**，通过**redis-lua脚本**完成
- 提交订单时不要提交购买的商品，去购物车数据库重新获取即可，防止购物车变化和修改页面值
- 但可以提交总额，防止商品金额变了还提交订单，用户不满意
- 其他信息可以用token和session获取

#### （1）订单数据

从属性可以看出，订单提交时需要带的数据

```java
@Data
public class OrderSubmitVo {

    /** 收获地址的id **/
    private Long addrId;

    /** 支付方式 **/
    private Integer payType;
    //无需提交要购买的商品，去购物车再获取一遍
    //优惠、发票

    /** 防重令牌 **/
    private String orderToken;

    /** 应付价格 **/
    private BigDecimal payPrice;

    /** 订单备注 **/
    private String remarks;

    //用户相关的信息，直接去session中取出即可
}
```

成功后转发至支付页面携带的数据

```java
@Data
public class SubmitOrderResponseVo {

    // 该实体为order表的映射
    private OrderEntity order;

    /** 错误状态码 **/
    private Integer code;
}
```

#### （2）提交订单

* 提交订单成功，则携带返回数据转发至支付页面
* 提交订单失败，则携带错误信息重定向至确认页

在OrderWebController里接收到下单请求，然后去OrderServiceImpl里验证和下单，然后再返回到OrderWebController。相当于OrderWebController是封装了我们原来的OrderServiceImpl，用作web的

调用service，service返回了失败Code信息，可以看是什么原因引起的下单失败

```java
@PostMapping("/submitOrder") // OrderWebController
public String submitOrder(OrderSubmitVo submitVo, Model model,
                          RedirectAttributes redirectAttributes){

    try {
        // 去OrderServiceImpl服务里验证和下单
        SubmitOrderResponseVo responseVo = orderService.submitOrder(submitVo);
        
        // 下单失败回到订单重新确认订单信息
        if(responseVo.getCode() == 0){
            // 下单成功去支付响应
            model.addAttribute("submitOrderResp", responseVo);
            // 支付页
            return "pay";
        }else{
            String msg = "下单失败";
            switch (responseVo.getCode()){
                case 1: msg += "订单信息过期,请刷新在提交";break;
                case 2: msg += "订单商品价格发送变化,请确认后再次提交";break;
                case 3: msg += "商品库存不足";break;
            }
            redirectAttributes.addFlashAttribute("msg", msg); 
            // 重定向
            return "redirect:http://order.gulimall.com/toTrade";
        }
    } catch (Exception e) {
        if (e instanceof NotStockException){
            String message = e.getMessage();
            redirectAttributes.addFlashAttribute("msg", message);
        }
        return "redirect:http://order.gulimall.com/toTrade";
    }
```

什么的逻辑其实是交给orderService.submitOrder(submitVo);

去做的，那么我们就接着往下看他是如何与令牌结合保证幂等性的

##### 1）验证原子性令牌

- 为防止在【获取令牌、对比值和删除令牌】之间发生错误导入令牌校验出错，我们必须使用lua脚本保证原子性操作
- 改为先锁库存再生成订单
- 库存服务后面讲

```java
//	@GlobalTransactional
@Transactional
@Override // OrderServiceImpl
public SubmitOrderResponseVo submitOrder(OrderSubmitVo vo) {
    // 当条线程共享这个对象
    confirmVoThreadLocal.set(vo);
    SubmitOrderResponseVo submitVo = new SubmitOrderResponseVo();
    // 0：正常
    submitVo.setCode(0);
    // 去服务器创建订单,验令牌,验价格,锁库存
    MemberRespVo MemberRespVo = LoginUserInterceptor.threadLocal.get();

    // 1. 验证令牌 [必须保证原子性] 返回 0 or 1
    // 0 令牌删除失败 1删除成功
    String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
    String orderToken = vo.getOrderToken();

    // 原子验证令牌 删除令牌
    Long result = stringRedisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
                                              Arrays.asList(OrderConstant.USER_ORDER_TOKEN_PREFIX + MemberRespVo.getId()),
                                              orderToken);
    if (result == 0L) { // 令牌验证失败

        submitVo.setCode(1);
    } else {  // 令牌验证成功
        // 1 .创建订单等信息
        OrderCreateTo order = createOrder();
        // 2. 验价
        BigDecimal payAmount = order.getOrder().getPayAmount();
        BigDecimal voPayPrice = vo.getPayPrice();
        if (Math.abs(payAmount.subtract(voPayPrice).doubleValue()) < 0.01) {
            // 金额对比成功
            // 3.保存订单 挪到后面

            // 4.库存锁定
            WareSkuLockVo lockVo = new WareSkuLockVo();
            lockVo.setOrderSn(order.getOrder().getOrderSn());
            List<OrderItemVo> locks = order.getOrderItems().stream().map(item -> {
                OrderItemVo itemVo = new OrderItemVo();
                // 锁定的skuId 这个skuId要锁定的数量
                itemVo.setSkuId(item.getSkuId());
                itemVo.setCount(item.getSkuQuantity());
                itemVo.setTitle(item.getSkuName());
                return itemVo;
            }).collect(Collectors.toList());

            lockVo.setLocks(locks);
            // 远程锁库存
            R r = wmsFeignService.orderLockStock(lockVo);
            if (r.getCode() == 0) {
                // 库存足够 锁定成功 给MQ发送订单消息，到时为支付则取消
                submitVo.setOrderEntity(order.getOrder());
                rabbitTemplate.convertAndSend(this.eventExchange, this.createOrder, order.getOrder());
                saveOrder(order);
                //					int i = 10/0;
            } else {
                // 锁定失败
                String msg = (String) r.get("msg");
                throw new NotStockException(msg);
            }
        } else {
            // 价格验证失败
            submitVo.setCode(2);
        }
    }
    return submitVo;
}
```





##### 2) 订单创建To

最终订单后要返回的数据

```java
@Data
public class OrderCreateTo {

    private OrderEntity order;

    private List<OrderItemEntity> orderItems;

    /** 订单计算的应付价格 **/
    private BigDecimal payPrice;

    /** 运费 **/
    private BigDecimal fare;
}
```

创建订单、订单项

- 用`IdWorker`生成订单号，是时间和本身对象的组合
- 构建订单。此时还没商品
  - 用threadlocal保存一些当前线程的数据，就不用写形参了
- 构建订单项。填入具体的商品，设计锁库存的问题
- 计算价格

```java
//2. 创建订单、订单项
OrderCreateTo order =createOrderTo(memberResponseVo,submitVo);

private OrderCreateTo createOrderTo(MemberResponseVo memberResponseVo, OrderSubmitVo submitVo) {
    //2.1 用IdWorker生成订单号
    String orderSn = IdWorker.getTimeId();
    //2.2 构建订单
    OrderEntity entity = buildOrder(memberResponseVo, submitVo,orderSn);
    //2.3 构建订单项
    List<OrderItemEntity> orderItemEntities = buildOrderItems(orderSn);
    //2.4 计算价格
    compute(entity, orderItemEntities);
    OrderCreateTo createTo = new OrderCreateTo();
    createTo.setOrder(entity);
    createTo.setOrderItems(orderItemEntities);
    return createTo;
}
```



###### 构建订单

```java
private OrderEntity buildOrder(MemberResponseVo memberResponseVo, OrderSubmitVo submitVo, String orderSn) {

    OrderEntity orderEntity =new OrderEntity();

    orderEntity.setOrderSn(orderSn);

    //1) 设置用户信息
    orderEntity.setMemberId(memberResponseVo.getId());
    orderEntity.setMemberUsername(memberResponseVo.getUsername());

    //2) 获取邮费和收件人信息并设置
    FareVo fareVo = wareFeignService.getFare(submitVo.getAddrId());
    BigDecimal fare = fareVo.getFare();
    orderEntity.setFreightAmount(fare);
    MemberAddressVo address = fareVo.getAddress();
    orderEntity.setReceiverName(address.getName());
    orderEntity.setReceiverPhone(address.getPhone());
    orderEntity.setReceiverPostCode(address.getPostCode());
    orderEntity.setReceiverProvince(address.getProvince());
    orderEntity.setReceiverCity(address.getCity());
    orderEntity.setReceiverRegion(address.getRegion());
    orderEntity.setReceiverDetailAddress(address.getDetailAddress());

    //3) 设置订单相关的状态信息
    orderEntity.setStatus(OrderStatusEnum.CREATE_NEW.getCode());
    orderEntity.setConfirmStatus(0);
    orderEntity.setAutoConfirmDay(7);

    return orderEntity;
}
```

#### 构建订单项

订单项指的是订单里具体的商品

- `StringUtils.collectionToDelimitedString(list, ";分隔符")`工具可以集合/数组转string
- 订单项得算优惠后的价格
- 用BigDecimal精确计算

```java
// OrderServiceImpl
private List<OrderItemEntity> buildOrderItems(String orderSn) {
    // 这里是最后一次来确认购物项的价格 这个远程方法还会查询一次数据库
    List<OrderItemVo> cartItems = cartFeignService.getCurrentUserCartItems();
    List<OrderItemEntity> itemEntities = null;
    if(cartItems != null && cartItems.size() > 0){
        itemEntities = cartItems.stream().map(cartItem -> {
            OrderItemEntity itemEntity = buildOrderItem(cartItem);
            itemEntity.setOrderSn(orderSn);
            return itemEntity;
        }).collect(Collectors.toList());
    }
    return itemEntities;
}
```

```java
/**
     * 构建某一个订单项
     */ // OrderServiceImpl
private OrderItemEntity buildOrderItem(OrderItemVo cartItem) {
    OrderItemEntity itemEntity = new OrderItemEntity();
    // 1.订单信息： 订单号
    // 已经在items里设置了

    // 2.商品spu信息
    Long skuId = cartItem.getSkuId();
    // 远程获取spu的信息
    R r = productFeignService.getSpuInfoBySkuId(skuId);
    SpuInfoVo spuInfo = r.getData(new TypeReference<SpuInfoVo>() {
    });
    itemEntity.setSpuId(spuInfo.getId());
    itemEntity.setSpuBrand(spuInfo.getBrandId().toString());
    itemEntity.setSpuName(spuInfo.getSpuName());
    itemEntity.setCategoryId(spuInfo.getCatalogId());

    // 3.商品的sku信息
    itemEntity.setSkuId(cartItem.getSkuId());
    itemEntity.setSkuName(cartItem.getTitle());
    itemEntity.setSkuPic(cartItem.getImage());
    itemEntity.setSkuPrice(cartItem.getPrice());
    // 把一个集合按照指定的字符串进行分割得到一个字符串
    // 属性list生成一个string
    String skuAttr = StringUtils.collectionToDelimitedString(cartItem.getSkuAttr(), ";");
    itemEntity.setSkuAttrsVals(skuAttr);
    itemEntity.setSkuQuantity(cartItem.getCount());
    // 4.积分信息 买的数量越多积分越多 成长值越多
    itemEntity.setGiftGrowth(cartItem.getPrice().multiply(new BigDecimal(cartItem.getCount())).intValue());
    itemEntity.setGiftIntegration(cartItem.getPrice().multiply(new BigDecimal(cartItem.getCount())).intValue());

    // 5.订单项的价格信息 优惠金额
    itemEntity.setPromotionAmount(new BigDecimal("0.0")); // 促销打折
    itemEntity.setCouponAmount(new BigDecimal("0.0")); // 优惠券
    itemEntity.setIntegrationAmount(new BigDecimal("0.0")); // 积分

    // 当前订单项的原价
    BigDecimal orign = itemEntity.getSkuPrice().multiply(new BigDecimal(itemEntity.getSkuQuantity().toString()));
    // 减去各种优惠的价格
    BigDecimal subtract =
        orign.subtract(itemEntity.getCouponAmount()) // 优惠券逻辑没有写，应该去coupon服务查用户的sku优惠券
        .subtract(itemEntity.getPromotionAmount()) // 官方促销
        .subtract(itemEntity.getIntegrationAmount()); // 京豆/积分
    itemEntity.setRealAmount(subtract);
    return itemEntity;
}
```

商品项价格计算完毕，接着去创建订单

```java
private OrderCreateTo createOrder() {

    OrderCreateTo orderCreateTo = new OrderCreateTo();
    // 1. 生成一个订单号
    String orderSn = IdWorker.getTimeId();
    // 填充订单的各种基本信息，价格信息
    OrderEntity orderEntity = buildOrderSn(orderSn);

    // 2. 获取所有订单项   // 从里面已经设置好了用户该使用的价格
    List<OrderItemEntity> items = buildOrderItems(orderSn);

    // 3.根据订单项计算价格	传入订单 、订单项 计算价格、积分、成长值等相关信息
    computerPrice(orderEntity, items);
    orderCreateTo.setOrder(orderEntity);
    orderCreateTo.setOrderItems(items);
    return orderCreateTo;
}
```

#### 计算总价

```java
private void computerPrice(OrderEntity orderEntity, List<OrderItemEntity> items) {

    // 叠加每一个订单项的金额
    BigDecimal coupon = new BigDecimal("0.0");
    BigDecimal integration = new BigDecimal("0.0");
    BigDecimal promotion = new BigDecimal("0.0");
    BigDecimal gift = new BigDecimal("0.0");
    BigDecimal growth = new BigDecimal("0.0");

    // 总价
    BigDecimal totalPrice = new BigDecimal("0.0");
    for (OrderItemEntity item : items) {  // 这段逻辑不是特别合理，最重要的是累积总价，别的可以跳过
        // 优惠券的金额
        coupon = coupon.add(item.getCouponAmount());
        // 积分优惠的金额
        integration = integration.add(item.getIntegrationAmount());
        // 打折的金额
        promotion = promotion.add(item.getPromotionAmount());
        BigDecimal realAmount = item.getRealAmount();
        totalPrice = totalPrice.add(realAmount);

        // 购物获取的积分、成长值
        gift.add(new BigDecimal(item.getGiftIntegration().toString()));
        growth.add(new BigDecimal(item.getGiftGrowth().toString()));
    }
    // 1.订单价格相关 总额、应付总额
    orderEntity.setTotalAmount(totalPrice);
    orderEntity.setPayAmount(totalPrice.add(orderEntity.getFreightAmount()));

    orderEntity.setPromotionAmount(promotion);
    orderEntity.setIntegrationAmount(integration);
    orderEntity.setCouponAmount(coupon);

    // 设置积分、成长值
    orderEntity.setIntegration(gift.intValue());
    orderEntity.setGrowth(growth.intValue());

    // 设置订单的删除状态
    orderEntity.setDeleteStatus(OrderStatusEnum.CREATE_NEW.getCode());
}
```

#### 3) 验价

计算完总价后，返回主逻辑

```java
//	@GlobalTransactional
@Transactional
@Override // OrderServiceImpl
public SubmitOrderResponseVo submitOrder(OrderSubmitVo vo) {

    // 1. 验证令牌 [必须保证原子性] 返回 0 or 1

    if (result == 0L) { // 令牌验证失败
    } else {  // 令牌验证成功
        // 1 .创建订单等信息
        OrderCreateTo order = createOrder();
        // 2. 验价
        BigDecimal payAmount = order.getOrder().getPayAmount();
        BigDecimal voPayPrice = vo.getPayPrice();// 获取带过来的价格
        if (Math.abs(payAmount.subtract(voPayPrice).doubleValue()) < 0.01) {
```



将`"页面提交的价格"`和`"后台计算的价格"`进行对比，若不同则提示用户`商品价格发生变化`

```java
BigDecimal payAmount = order.getOrder().getPayAmount();
BigDecimal payPrice = submitVo.getPayPrice();
if (Math.abs(payAmount.subtract(payPrice).doubleValue()) < 0.01) {
			/****************/
}else {
    //验价失败
    responseVo.setCode(2);
    return responseVo;
}
```

#### 4) 保存订单到db

```java
private void saveOrder(OrderCreateTo orderCreateTo) {
    OrderEntity order = orderCreateTo.getOrder();
    order.setCreateTime(new Date());
    order.setModifyTime(new Date());
    this.save(order);
    orderItemService.saveBatch(orderCreateTo.getOrderItems());
}
```

#### 5) 锁定库存，发送延迟队列

- 锁定库存失败要取消订单

```java
// 在订单里的逻辑：
// 前面是创建订单、订单项、验价等逻辑...
// .....
// 
List<OrderItemVo> orderItemVos = order.getOrderItems().stream().map((item) -> {
    OrderItemVo orderItemVo = new OrderItemVo();
    orderItemVo.setSkuId(item.getSkuId());
    orderItemVo.setCount(item.getSkuQuantity());
    return orderItemVo;
}).collect(Collectors.toList());
// 去锁库存 @RequestMapping("/lock/order")
R r = wareFeignService.orderLockStock(orderItemVos);
//5.1 锁定库存成功
if (r.getCode()==0){
    responseVo.setOrder(order.getOrder());
    responseVo.setCode(0);
    return responseVo;
}else {
    //5.2 锁定库存失败
    String msg = (String) r.get("msg");
    throw new NoStockException(msg);
}
```

远程服务

```java
@RequestMapping("/lock/order")
public R orderLockStock(@RequestBody List<OrderItemVo> itemVos) {
    try {
        Boolean lock = wareSkuService.orderLockStock(itemVos);
        return R.ok();
    } catch (NoStockException e) {
        return R.error(BizCodeEnum.NO_STOCK_EXCEPTION.getCode(), BizCodeEnum.NO_STOCK_EXCEPTION.getMsg());
    }
}
```

* 找出所有库存大于商品数的仓库
* 遍历所有满足条件的仓库，逐个尝试锁库存，若锁库存成功则退出遍历

```xml
<update id="lockSkuStock">
    UPDATE `wms_ware_sku` SET stock_locked = stock_locked + #{num}
    WHERE sku_id = #{skuId} 
    AND ware_id = #{wareId} 
    AND stock-stock_locked >= #{num}
</update>
```

- for遍历sku
  - for遍历仓库
    -  wareSkuDao.lockSkuStock(skuId, wareId, hasStock.getNum());
    - cas锁库存成功后发送延迟队列

```java
@Transactional // 事务
@Override
public Boolean orderLockStock(List<OrderItemVo> itemVos) {
    List<SkuLockVo> lockVos = itemVos.stream().map((item) -> {
        SkuLockVo skuLockVo = new SkuLockVo();
        skuLockVo.setSkuId(item.getSkuId());
        skuLockVo.setNum(item.getCount());
        //找出所有库存大于商品数的仓库// 这个地方问题很大，后面得改
        List<Long> wareIds = baseMapper.listWareIdsHasStock(item.getSkuId(), item.getCount());
        skuLockVo.setWareIds(wareIds);
        return skuLockVo;
    }).collect(Collectors.toList());

    for (SkuLockVo lockVo : lockVos) {
        boolean lock = true;
        Long skuId = lockVo.getSkuId();
        List<Long> wareIds = lockVo.getWareIds();
        //如果没有满足条件的仓库，抛出异常
        if (wareIds == null || wareIds.size() == 0) {
            throw new NoStockException(skuId);
        }else {
        // 遍历仓库
            for (Long wareId : wareIds) {
            //  锁库存，更新sql用到了cas，如果返回非0代表更新对了
                Long count=baseMapper.lockWareSku(skuId, lockVo.getNum(), wareId);
                if (count==0){
                    lock=false;
                }else {
                    lock = true;
                    break;
                }
            }
        }
        if (!lock) throw new NoStockException(skuId);
    }
    return true;
}
```

这里通过异常机制控制事务回滚，如果在锁定库存失败则抛出`NoStockException`s,订单服务和库存服务都会回滚。

> 后面有消息队列后，会进行优化
>
> 优化逻辑为：锁库存后，把内容发到消息队列里
>
> 消息队列并不立刻消费，而是让其过期，过期后重新入队别的消息队列，别的消息队列拿到后验证订单是否被支付，没被支付的话还原到库存里。

## ==十、分布式事务==

这部分内容写到了另外一个文件中

## ==十一、支付==



https://open.alipay.com/platform/home.htm

https://opendocs.alipay.com/open/200/105310



#### (1) 支付宝加密原理

* 支付宝加密采用RSA非对称加密，分别在商户端和支付宝端有两对公钥和私钥
* 在发送订单数据时，直接使用明文，但会使用`商户私钥`加一个对应的签名，支付宝端会使用`商户公钥`对签名进行验签，只有数据明文和签名对应的时候才能说明传输正确
* 支付成功后，支付宝发送支付成功数据之外，还会使用`支付宝私钥`加一个对应的签名，商户端收到支付成功数据之后也会使用`支付宝公钥`延签，成功后才能确认（就是把摘要和信息都带过去，支付的再验证一次）

> 支付成功后用户立即得到响应页面，而订单其他内容交给**消息队列**去做即可

#### (2) 配置支付宝沙箱环境

![image](http://mdn.alipayobjects.com/afts/img/A*z5SNSoEcVQcAAAAAAAAAAABkAa8wAA/original?bz=openpt_doc&t=IDa3brls1x3D528fVLNScQAAAABkMK8AAAAA)

要申请的话会很麻烦，还得传营业执照，而 沙箱环境是测试环境

点击 **研发服务** 即可进入 [沙箱环境](https://openhome.alipay.com/platform/appDaily.htm)。



#### (3) 环境搭建

导入支付宝sdk

```xml
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>4.9.28.ALL</version>
</dependency>
```

抽取支付工具类并进行配置

成功调用该接口后，返回的数据就是支付页面的html，因此后续会使用`@ResponseBody`

```java
@ConfigurationProperties(prefix = "alipay")
@Component
@Data
public class AlipayTemplate {

    //在支付宝创建的应用的id
    private   String app_id = "2021000118616614";

    // 商户私钥，您的PKCS8格式RSA2私钥
    private String merchant_private_key = "MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC8csTb9D+AQgBTUnX58b1XwCo/8vAXiSwml4wioYBGZYsVZTruUPtJAu1nSx65KVMyJq83EE+VIqWEW3r8RkrG/C4Dl5xr/5rz0c15ZWUpTr7dpyzvFFfux62xUYmPmfs1DnhX3ei6ZWIRdadck2v2BFMDcnfzh31nkDy4wBMxpVyNNxG7v3Z512xZ3NVWC1JNAlklcO4AULHO+CrISZocovmIwuIsNkURQEh3ycXhlMxd8oen08DKrVuY+wEDFvIOFZ7VK5tRAwhFG3mbuJj02Jhv7weWp8/MAApXLe8rFu9WyKl9cre+8e0trBrnRszgEszjwgTtxcn/ZF+pwIEzAgMBAAECggEAKorSTEGAkGjV//lursVXFFdKcnNapkWOVQwDU9IXzkygMG1Q93oKsHnbtGTuA6kDoh+/kHO7M5TFvvKT+h24ReGqVZ9FbdAfYAmuFEjCpKelSQ6zgymZjEtBt/ULVALUBi9FFbkAEAxRLlXcOXcCeWCSiQWvdKfStK2IN8EM1Dj33/Fp94lXV+IJJN2nr8vXZMwwMdx/FJOjPlluGdXna6f0lW/inelL9jaAREjr35rp8kMzx2gpdM8JDvbXT9Gjlbi7H22qX13f2wiM7DxnUzSLjReSVs5MhnBLto1FKFV7vbOWh+/Be0HRieoK/EqkhVBhqOi7EENBxtuz0+RGYQKBgQDx/3VfVcCEbCKVzu8zd9K/nLfKhGs6J1UNe22CqyONHLcy4MDZ5QNnS0D4AEXRHDlGEz9CQleLjpk1OMCBAM+XxLWWHuZ9q+F/F/+yqysuq5mkDl+0gHhUECiZYkiweJIs7/9Sbr9WiVefxnYEIdVcnQNTuWZEd3nWi5glqvmPkQKBgQDHWh56Vkvt5ZvD7RwZVqRIIrliR7nhlBqii1mTwsHGToFf9JD0ksfDFUokYdTUCqSaf7J94XIoPZNY/NLd4mPPMp20gxu2e6+J9NlVc7jNP+MdHnTGKdBCJ0emRS6vOf25b26vVDhCuJUUkSTfwj+b1P8xBgy2JkgKL8nB8/pqgwKBgQC/yWhY5NoNWLHULksObCEe8HIMUwOz8+YJKE+y5jTnqeFathrA1SnsXAyiP30Va5vMeIaC2ZcOKDYtosuVsXHUYvZSgizDXkv48KkaDWPMufyqsyWQJNy4KpIydV0MVpHqgU3FI7YKPBCwtJVlUvcITfuMB/wPuOxbZwhumeDssQKBgCk2s2hdYPM87fgSlCWU6P/U1fjAlWhSgzMplgpbUE5cOpkI6dL2aYAmbZ6Z7zMrRB6A2fj2W/B/0m+qTTn8LOBQOZRxKpCOf5sI2Mm20/TzCVQi0MeLK3gRwNlaIi2t0ou8wuhShBMfMAsBetsbwKTJ4zxSYNxji683dAG6HAJbAoGBAOeQ9QOndWIkwidGL9DqLL0zOCxk0+i5VR+ih+eKXYAxR7CWBTnZiVniKtb4ncPvXOuIL6j3T0Uo3YmsitwsP4u/SDnhx7YjxVcx5JWy5bGe9R7luUTWRqlD8BAAHhH9n0+UTxFe87j54e2/Llu/XZojImDmUm9S+fSb6V12xXqv";

    // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。
    private String alipay_public_key = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAhwMXBRuVOK/N6pQz9OSrGaN+yyZX0NEpsH4BbbQoZV0qwacqEXhfaVO5m2eGf3n1fAt14OmKa4eoOTjJLh7vEdmLY9tgM8YNBJ/tSJF2iN9VFEZ3YX67PI5ER6DWsGf72Cj65+iK91k+y8xyf0uyOy9CjIYh1MnTjKuzZdrKDRq/rpeUTD9/SjMM+1BUHmZ2tWiwCOGt6z1olgYDW7DA2rAqYpojCOkc98p8dWJwCGHkYMNc5QSeMs1jcNLuAoOQIPRPaZrZMEAGhKIckUWD86mGPzHNGcuBWeSMlCDNxgjsgCiql1g+goSs+e6Ea37ymeK+cgL8iIYgcd3Qb4TYpwIDAQAB";

    // 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    // 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息
    private  String notify_url="http://**.natappfree.cc/payed/notify";

    // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    //同步通知，支付成功，一般跳转到成功页
    private  String return_url="http://order.gulimall.com/memberOrder.html";

    // 签名方式
    private  String sign_type = "RSA2";

    // 字符编码格式
    private  String charset = "utf-8";

    // 支付宝网关； https://openapi.alipaydev.com/gateway.do
    private  String gatewayUrl = "https://openapi.alipaydev.com/gateway.do";

    public  String pay(PayVo vo) throws AlipayApiException {

        //AlipayClient alipayClient = new DefaultAlipayClient(AlipayTemplate.gatewayUrl, AlipayTemplate.app_id, AlipayTemplate.merchant_private_key, "json", AlipayTemplate.charset, AlipayTemplate.alipay_public_key, AlipayTemplate.sign_type);
        //1、根据支付宝的配置生成一个支付客户端
        AlipayClient alipayClient = new DefaultAlipayClient(gatewayUrl,
                app_id, merchant_private_key, "json",
                charset, alipay_public_key, sign_type);

        //2、创建一个支付请求 //设置请求参数
        AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();
        alipayRequest.setReturnUrl(return_url);
        alipayRequest.setNotifyUrl(notify_url);

        //商户订单号，商户网站订单系统中唯一订单号，必填
        String out_trade_no = vo.getOut_trade_no();
        //付款金额，必填
        String total_amount = vo.getTotal_amount();
        //订单名称，必填
        String subject = vo.getSubject();
        //商品描述，可空
        String body = vo.getBody();

        alipayRequest.setBizContent("{\"out_trade_no\":\""+ out_trade_no +"\","
                + "\"total_amount\":\""+ total_amount +"\","
                + "\"subject\":\""+ subject +"\","
                + "\"body\":\""+ body +"\","
                + "\"product_code\":\"FAST_INSTANT_TRADE_PAY\"}");

        String result = alipayClient.pageExecute(alipayRequest).getBody();

        //会收到支付宝的响应，响应的是一个页面，只要浏览器显示这个页面，就会自动来到支付宝的收银台页面
        System.out.println("支付宝的响应："+result);

        return result;

    }
```

#### (4) 订单支付与同步通知

点击支付跳转到支付接口

```java
@ResponseBody
@GetMapping(value = "/aliPayOrder",produces = "text/html")
public String aliPayOrder(@RequestParam("orderSn") String orderSn) throws AlipayApiException {
    System.out.println("接收到订单信息orderSn："+orderSn);
    //获取当前订单并设置支付订单相关信息
    PayVo payVo = orderService.getOrderPay(orderSn);
    String pay = alipayTemplate.pay(payVo);
    return pay;
}

@Override
public PayVo getOrderPay(String orderSn) {
    OrderEntity orderEntity = this.getOne(new QueryWrapper<OrderEntity>().eq("order_sn", orderSn));
    PayVo payVo = new PayVo();
    //交易号
    payVo.setOut_trade_no(orderSn);
    //支付金额设置为两位小数，否则会报错
    BigDecimal payAmount = orderEntity.getPayAmount().setScale(2, BigDecimal.ROUND_UP);
    payVo.setTotal_amount(payAmount.toString());

    List<OrderItemEntity> orderItemEntities = orderItemService.list(new QueryWrapper<OrderItemEntity>().eq("order_sn", orderSn));
    OrderItemEntity orderItemEntity = orderItemEntities.get(0);
    //订单名称
    payVo.setSubject(orderItemEntity.getSkuName());
    //商品描述
    payVo.setBody(orderItemEntity.getSkuAttrsVals());
    return payVo;
}
```

设置成功回调地址为订单详情页

```java
  	// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    //同步通知，支付成功，一般跳转到成功页
    private  String return_url="http://order.gulimall.com/memberOrder.html";

	  /**
     * 获取当前用户的所有订单
     * @return
     */
    @RequestMapping("/memberOrder.html")
    public String memberOrder(@RequestParam(value = "pageNum",required = false,defaultValue = "0") Integer pageNum,Model model){
        Map<String, Object> params = new HashMap<>();
        params.put("page", pageNum.toString());
        //分页查询当前用户的所有订单及对应订单项
        PageUtils page = orderService.getMemberOrderPage(params);
        model.addAttribute("pageUtil", page);
        //返回至订单详情页
        return "list";
    }

```

#### (5) 异步通知

* 订单支付成功后支付宝会回调商户接口，这个时候需要修改订单状态
* 由于同步跳转可能由于网络问题失败，所以使用异步通知
* 支付宝使用的是最大努力通知方案，保障数据一致性，隔一段时间会通知商户支付成功，直到返回`success`

##### 1）内网穿透设置异步通知地址

* 将外网映射到本地的`order.gulimall.com:80`

* 由于回调的请求头不是`order.gulimall.com`，因此nginx转发到网关后找不到对应的服务，所以需要对nginx进行设置

  <img src="D:images/Snipaste_2020-10-18_12-18-28.png" style="zoom:38%;" />

  将`/payed/notify`异步通知转发至订单服务

设置异步通知的地址

```java
// 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
// 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息
private  String notify_url="http://****.natappfree.cc/payed/notify";
```

##### 2）验证签名

```java
@PostMapping("/payed/notify")
public String handlerAlipay(HttpServletRequest request, PayAsyncVo payAsyncVo) throws AlipayApiException {
    System.out.println("收到支付宝异步通知******************");
    // 只要收到支付宝的异步通知，返回 success 支付宝便不再通知
    // 获取支付宝POST过来反馈信息
    //TODO 需要验签
    Map<String, String> params = new HashMap<>();
    Map<String, String[]> requestParams = request.getParameterMap();
    for (String name : requestParams.keySet()) {
        String[] values = requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i]
                    : valueStr + values[i] + ",";
        }
        //乱码解决，这段代码在出现乱码时使用
        // valueStr = new String(valueStr.getBytes("ISO-8859-1"), "utf-8");
        params.put(name, valueStr);
    }

    boolean signVerified = AlipaySignature.rsaCheckV1(params, alipayTemplate.getAlipay_public_key(),
            alipayTemplate.getCharset(), alipayTemplate.getSign_type()); //调用SDK验证签名

    if (signVerified){
        System.out.println("支付宝异步通知验签成功");
        //修改订单状态
        orderService.handlerPayResult(payAsyncVo);
        return "success";
    }else {
        System.out.println("支付宝异步通知验签失败");
        return "error";
    }
}
```

##### 3）修改订单状态与保存交易流水

```java
@Override
public void handlerPayResult(PayAsyncVo payAsyncVo) {
    //保存交易流水
    PaymentInfoEntity infoEntity = new PaymentInfoEntity();
    String orderSn = payAsyncVo.getOut_trade_no();
    infoEntity.setOrderSn(orderSn);
    infoEntity.setAlipayTradeNo(payAsyncVo.getTrade_no());
    infoEntity.setSubject(payAsyncVo.getSubject());
    String trade_status = payAsyncVo.getTrade_status();
    infoEntity.setPaymentStatus(trade_status);
    infoEntity.setCreateTime(new Date());
    infoEntity.setCallbackTime(payAsyncVo.getNotify_time());
    paymentInfoService.save(infoEntity);

    //判断交易状态是否成功
    if (trade_status.equals("TRADE_SUCCESS") || trade_status.equals("TRADE_FINISHED")) {
        baseMapper.updateOrderStatus(orderSn, OrderStatusEnum.PAYED.getCode(), PayConstant.ALIPAY);
    }
```

##### 4) 异步通知的参数

```java
@PostMapping("/payed/notify")
public String handlerAlipay(HttpServletRequest request) {
    System.out.println("收到支付宝异步通知******************");
    Map<String, String[]> parameterMap = request.getParameterMap();
    for (String key : parameterMap.keySet()) {
        String value = request.getParameter(key);
        System.out.println("key:"+key+"===========>value:"+value);
    }
    return "success";
}
```

```shell
收到支付宝异步通知******************
key:gmt_create===========>value:2020-10-18 09:13:26
key:charset===========>value:utf-8
key:gmt_payment===========>value:2020-10-18 09:13:34
key:notify_time===========>value:2020-10-18 09:13:35
key:subject===========>value:华为
key:sign===========>value:aqhKWzgzTLE84Scy5d8i3f+t9f7t7IE5tK/s5iHf3SdFQXPnTt6MEVtbr15ZXmITEo015nCbSXaUFJvLiAhWpvkNEd6ysraa+2dMgotuHPIHnIUFwvdk+U4Ez+2A4DBTJgmwtc5Ay8mYLpHLNR9ASuEmkxxK2F3Ov6MO0d+1DOjw9c/CCRRBWR8NHSJePAy/UxMzULLtpMELQ1KUVHLgZC5yym5TYSuRmltYpLHOuoJhJw8vGkh2+4FngvjtS7SBhEhR1GvJCYm1iXRFTNgP9Fmflw+EjxrDafCIA+r69ZqoJJ2Sk1hb4cBsXgNrFXR2Uj4+rQ1Ec74bIjT98f1KpA==
key:buyer_id===========>value:2088622954825223
key:body===========>value:上市年份：2020；内存：64G
key:invoice_amount===========>value:6300.00
key:version===========>value:1.0
key:notify_id===========>value:2020101800222091334025220507700182
key:fund_bill_list===========>value:[{"amount":"6300.00","fundChannel":"ALIPAYACCOUNT"}]
key:notify_type===========>value:trade_status_sync
key:out_trade_no===========>value:12345523123
key:total_amount===========>value:6300.00
key:trade_status===========>value:TRADE_SUCCESS
key:trade_no===========>value:2020101822001425220501264292
key:auth_app_id===========>value:2016102600763190
key:receipt_amount===========>value:6300.00
key:point_amount===========>value:0.00
key:app_id===========>value:2016102600763190
key:buyer_pay_amount===========>value:6300.00
key:sign_type===========>value:RSA2
key:seller_id===========>value:2088102181115314
```

各参数详细意义见[支付宝开放平台异步通知](https://opendocs.alipay.com/open/194/103296)

#### (6) 收单

由于可能出现订单已经过期后，库存已经解锁，但支付成功后再修改订单状态的情况，需要设置支付有效时间，只有在有效期内才能进行支付

```java
alipayRequest.setBizContent("{\"out_trade_no\":\""+ out_trade_no +"\","
        + "\"total_amount\":\""+ total_amount +"\","
        + "\"subject\":\""+ subject +"\","
        + "\"body\":\""+ body +"\","
        //设置过期时间为1m
        +"\"timeout_express\":\"1m\","
        + "\"product_code\":\"FAST_INSTANT_TRADE_PAY\"}");
```

超时后订单显示："抱歉您的交易因超时已失败"’

## 笔记不易：



离线笔记均为markdown格式，图片也是云图，10多篇笔记20W字，压缩包仅500k，推荐使用typora阅读。也可以自己导入有道云笔记等软件中

阿里云图床现在**每周得几十元充值**，都要自己往里搭了，麻烦不要散播与转发

![](https://i0.hdslb.com/bfs/album/ff3fb7e24f05c6a850ede4b1f3acc54312c3b0c6.png)

打赏后请主动发支付信息到邮箱  553736044@qq.com  ，上班期间很容易忽略收账信息，邮箱回邮基本秒回

禁止转载发布，禁止散播，若发现大量散播，将对本系统文章图床进行重置处理。

技术人就该干点技术人该干的事



如果帮到了你，留下赞吧，谢谢支持