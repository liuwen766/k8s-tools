- Kubernetes 调度器里的另一个重要机制，即：优先级（Priority ）和抢占（Preemption）机制。【解决的是 Pod 调度失败时该怎么办的问题】
- 优先级（Priority ）：Kubernetes 调度器里维护着一个调度队列。所以，当 Pod 拥有了优先级之后【eg：expamle-PriorityClass.yaml】，高优先级的
  Pod 就可能会比低优先级的 Pod 提前出队，从而尽早完成调度过程。这个过程，就是“优先级”这个概念在 Kubernetes 里的主要体现。
- 抢占（Preemption）：当一个高优先级的 Pod 调度失败的时候，调度器的抢占能力就会被触发。调度器就会试图从当前集群里寻找一个节点，使得当这个节点上
  的一个或者多个低优先级 Pod 被删除后，待调度的高优先级 Pod 就可以被调度到这个节点上。这个过程，就是“抢占”这个概念在
  Kubernetes 里的主要体现。
- 被抢占的 Pod 是有一定的“优雅退出”时间（默认是 30s）的。而在这段时间里，其他的节点也是有可能变成可调度的，
  或者直接有新的节点被添加到这个集群中来。所以，鉴于优雅退出期间，集群的可调度性可能会发生的变化，把抢占者交给下一个调度周期再处理。


- Kubernetes 调度器实现抢占算法的一个最重要的设计，就是在调度队列的实现里，使用了两个不同的队列。
- 第一个队列，叫作 activeQ。凡是在 activeQ 里的 Pod，都是下一个调度周期需要调度的对象。
- 第二个队列，叫作 unschedulableQ，专门用来存放调度失败的 Pod。当一个 unschedulableQ 里的 Pod 被更新之后，调度器会自动把这个
  Pod 移动到 activeQ 里，从而给这些调度失败的 Pod “重新调度”的机会。

- 调度器为抢占者寻找牺牲者的流程：
- 第一步，调度器会检查这次失败事件的原因，来确认抢占是不是可以帮助抢占者找到一个新节点。
- 第二步，如果确定抢占可以发生，那么调度器就会把自己缓存的所有节点信息复制一份，然后使用这个副本来模拟抢占过程。

- 在得到了最佳的抢占结果之后，这个结果里的 Node，就是即将被抢占的 Node；被删除的 Pod
  列表，就是牺牲者。所以接下来，调度器就可以真正开始抢占的操作了，这个过程，又可以分为三步。
- 第一步，调度器会检查牺牲者【被抢占者】列表，清理这些 Pod 所携带的 nominatedNodeName 字段。
- 第二步，调度器会把抢占者的 nominatedNodeName，设置为被抢占的 Node 的名字。
- 第三步，调度器会开启一个 Goroutine，同步地删除牺牲者。

- 在为某一对 Pod 和 Node 执行 Predicates 算法的时候，如果待检查的 Node 是一个即将被抢占的节点，即：调度队列里有
  nominatedNodeName 字段值是该 Node 名字的 Pod 存在（可以称之为：“潜在的抢占者”）。那么，调度器就会对这个 Node ，将同样的
  Predicates 算法运行两遍。
- 第一遍， 调度器会假设上述“潜在的抢占者”已经运行在这个节点上，然后执行 Predicates 算法；
- 第二遍， 调度器会正常执行 Predicates 算法，即：不考虑任何“潜在的抢占者”。
- 而只有这两遍 Predicates 算法都能通过时，这个 Pod 和 Node 才会被认为是可以绑定（bind）的。

- Kubernetes 里关于 Pod 的优先级和抢占机制的设计与实现。建议在 Kubernetes 集群中开启这两个特性，以便实现更高的资源使用率。
