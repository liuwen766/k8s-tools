# Redis多机数据库

Redis数据结构与对象：https://blog.csdn.net/qq_41822345/article/details/130456081

Redis单机数据库：https://blog.csdn.net/qq_41822345/article/details/130909789

> 先总结一下Redis的四种部署模式：
>
> - 1、单机模式
>   - 概念：Redis单机模式是最简单的部署模式，Redis将数据存储在单个节点上。 
>   - 优点
>     - 简单易用。架构简单，部署方便。
>     - 低延迟高性能。毕竟是单机，少了很多的网络传输。
>   - 缺点
>     - 无法保证数据的可靠性。
>     - 处理能力有限。受限于单核CPU的处理能力。
>     - 内存容量有限 。因此一般不会用于生产环境。
>
> - 2、主从复制模式
>
>   - 概念：主从模式是指可以让一个服务器（slave）去复制另一个服务器（master）的数据。
>   - 优点
>     - 数据备份。Master能自动将数据同步到Slave，且同步是以非阻塞bgsave的方式进行的。 
>     - 读写分离。 分担Master的读压力。
>   - 缺点
>     - 不具备自动容错与恢复功能。
>     - 有数据不一致的风险。比如master宕机。
>     - 难以支持在线扩容，Redis的容量仍然受限于单机配置 
>
> - 3、哨兵模式
>
>   - 概念： 哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。
>   - 优点
>     - 主从复制模式有的优点，哨兵模式也有。
>     - 系统可用性更高。master挂掉可以自动进行切换。
>   - 缺点
>     - 主从复制模式有的优点，哨兵模式也有。
>     - 需要额外的资源来启动sentinel进程，实现相对复杂一点。
>
> - 4、集群模式
>
>   - 概念：集群模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。 
>
>   - 优点
>
>     - 无中心架构。
>     - 可维护性。降低运维成本，提高系统的扩展性和可用性。
>     - 高可扩展。可线性扩展到1000多个节点，节点可动态添加或删除。
>     - 高可用性。部分节点不可用时，集群仍可用。
>
>   - 缺点
>
>     - 架构复杂性。客户端实现的复杂性。开发难度提高。
>
>     - 数据通过异步复制，不保证数据的强一致性。
>     - slave节点只能作为数据备份，不能缓解读压力。
>     - 不支持多数据库，只有1个数据库空间db0。
>     - 运维复杂，需要面临更多问题：比如Key事务操作、big-key/hot-key的处理更加复杂。

## 一、主从复制

> 主从复制还是哨兵和集群能够实施的基础，因此可以说主从复制是Redis高可用的基石。 

主从模式是指通过执行 slaveof 命令或设置 slaveof 选项，让一个服务器（slave）去复制另一个服务器（master）的数据。

只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。

### 1、旧版复制功能的实现

Redis的复制功能分为 **同步** 和 **命令传播** 两个操作。

#### a、同步

一个redis实例变成另一个redis实例的从节点有三种方式。

- 启动前：在从服务器的配置文件中加入slaveof配置；
- 启动时：在redis-server启动命令后加入--slaveof；
- 启动后：直接在客户端执行命令：slaveof ，则该Redis实例成为从节点。

**当redis实例通过上述方式变成一个从节点后，首先要执行同步操作——通过向主服务器发送SYNC命令来完成**，步骤如下：

- step1：从服务节点向主服务器发送`sync`命令；
- step2：主服务节点执行`bgsave`命令，后台生成RDB文件的同时，并使用缓冲区记录之后的所有写命令；
- step3：主服务节点将生成的RDB文件发送给从服务器；
- step4：从服务节点载入RDB文件，将自己的数据库状态更新至主服务节点执行`bgsave`命令时的数据库状态；
- step5：主服务器将缓冲区的所有写命令发送给从服务器；
- step6：从服务器执行这些写命令，将自己与主服务节点完全同步。

#### b、命令传播

当主服务器执行新的写命令时，主从服务器就可能出现不一致状态。这时主服务器需要对从服务器执行**命令传播**操作：将写命令传播给从服务器，这也是从服务器唯一能接收写命令的方式。

### 2、旧版复制功能的缺陷

以上复制方式在从节点**初次复制**主节点时，没有什么问题，但是当**断线后重复制**时，从节点需要再次发送`sync`命令，相当于初次复制。这种为了让从服务器补足一小部分缺失的数据，但却要把所有数据重新复制一遍的做法是非常低效的。

> - `SYNC` 命令是一个非常耗费资源的操作【非必要时不要执行这个命令】
>   - 主服务器需要执行 bgsave 命令，这需要耗费主服务器大量的CPU、内存和I/O资源。
>   - 主服务器将RDB文件发送给从服务器，这占用主服务器和从服务器大量的网络资源。
>   - 从服务器在载入RDB文件的期间，会因为阻塞无法处理其它命令请求。

### 3、新版复制功能的实现

> 从Redis2.8版本开始，使用 `PSYNC` 代替 `SYNC` 命令，它有两种模式：完整同步模式和部分同步模式。
>
> 完整同步模式用于处理复制，等同于旧版复制功能。
>
> 部分同步模式解决了旧版复制功能在处理断线后重复制时出现的低效问题。
>
> 部分同步模式只需要将从服务器缺少的写命令发送给从服务器执行就可以了。

#### a、部分同步功能

部分同步功能的实现基于以下三个部分构成：

- 复制偏移量offset

- 复制积压缓冲区

- 服务器的运行ID

  实现原理简述：从服务器发生断连时，它会向主服务器发送`PSYNC 主服务器运行ID 复制偏移量offset` 请求进行部分同步。主服务器接收到从服务器的`PSYNC`命令之后，首先对比从服务器传来的 **主服务器运行ID** ，如果和自己一致，那就检测从**复制偏移量offset**之后的数据是否存在于**复制积压缓冲区**，如果存在，则响应 `+CONTINUE`回复给从服务器，表示可以进行部分同步操作。

#### b、复制实现步骤

- 1、连接建立阶段【主从服务器状态属性中互相保存IP:port的过程】
  
  - step1、保存主节点信息
  
    从服务器节点执行完slave of命令之后，会将主服务器的IP：port保存到从服务器节点状态中的masterhost属性和masterport属性，然后返回OK给客户端。
  
  - step2、建立socket连接
  
    从服务器根据step1中保存的IP：port，创建连向主服务器的socket。主服务器在accept从服务器的连接之后，也会创建相应的socket。至此，主从服务器将基于此socket对进行通信。
  
  - step3、发送ping命令
  
    从服务器向主服务器发出ping进行连接测试，如果收到响应pong说明连接测试成功。否则断开连接并重连master。
  
  - step4、身份验证
  
    如果需要认证【主从双方都配置了密码】，则进行认证成功之后才能进行下一步。
  
  - step5、发送从节点端口信息
  
    从服务器执行命令 `replconf litsten-port port` 向主服务器发送端口。主服务状态中属性中保存从服务器的IP：port。
- 2、数据同步阶段
  - step1、首先，从节点根据当前状态，决定如何调用 `psync`命令。
    - 全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。
    - 部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。
  - step2、主节点根据收到的 `psync` 命令，及当前服务器状态，决定执行全量复制还是部分复制。
    - 如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送 `sync` 命令执行全量复制；
    - 如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复 `+CONTINUE`，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；
    - 如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复 `+FULLRESYNC` ，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。
- 3、命令传播阶段
  - step1、在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
  - step2、在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：`PING` 和 `REPLCONF ACK`。

### 4、心跳检测

主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，同时从服务器也需要通过向主服务器发送 `replconf ack` 命令（每秒一次）来进行心跳检测。

心跳检测有三个作用：

- 1、检测主从服务器的网络连接状态

  主服务器如果有超过1秒的时间没有收到来自从服务器的心跳检测命令 `replconf ack` ，那么主服务器就知道主从服务器之间的连接有问题了。通过 `info replication` 命令可以看到从服务器最后一次向主服务器的心跳检测过了多少秒。一般延迟（lag）值在0到1秒之间属于正常。

- 2、辅助实现min-slaves配置选项

  主服务器一般会配有设置 `min-slaves-to-write` 和 `min-slaves-max-lag` 参数。表示如果slave少于 `min-slaves-to-write`  个 或者有  `min-slaves-to-write` 个slave的延迟（lag）都不小于  `min-slaves-max-lag`秒，则主服务器拒绝写命令。

- 3、检测命令丢失

  从服务器会在发送 `replconf ack` 命令中告诉主服务器自己的复制偏移量offset，主服务器如果发现偏移量比自己少，就知道有命令发生的丢失，这时主服务器会从自己的复制积压区找到从服务器缺少的数据，重新发送给从服务器。（补发缺失数据 与 部分重同步原理一样【都是Redis 2.8版本新增的功能】，它们的区别是前者未发生断连，只是丢失了某些命令，而后者属于发生了断线并重连）

## 二、哨兵

哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。 

由一个或多个Sentinel去监听（并且Sentinel也可以互相监视）任意多个主服务以及主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已经下线的主服务器继续处理命令请求。

### 1、Sentinel概念

- Sentinel 本质上只是一个运行在特殊模式下的Redis服务器。

- Sentinel可以监控任意多个Master和该Master下的Slaves（ 即多个主从模式） 。

- 在同一个Sentinel哨兵下的，不同主从模型彼此之间相互独立，

- Sentinel的三个任务
  - 监控
  
    Sentinel 会不断地检查主服务器和从服务器是否运作正常。 

  - 提醒
  
    当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。 
  
  - 自动故障迁移
  
    当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作，将其中一个从服务器升级为新的主服务器。
  
- Sentinel网络
  - sentinel本身是监督者的身份，没有存储功能。
  - 监控同一个Master的Sentinel会自动连接，组成一个分布式的Sentinel网络，互相通信并交换彼此关于被监视服务器的信息。
  - 在整个体系中一个sentinel者或一群sentinels与主从服务架构体系是监督与被监督的关系。
  - 为什么需要一个这样的Sentinel网络？
    - sentinel在整个架构体系中有如下三种交互：sentinel与主服务器、sentinel与从服务器、sentinel与其他sentinel。
    - 既然是交互，首先无可避免的就要构建这样的一个交互网络，需要节点的注册与发现、节点之间的通信连接、节点保活、节点之间的通信协议等。

### 2、Sentinel初始化流程

Redis在哨兵模式下，在监控主从服务器之间，需要先完成Sentinel节点的初始化。流程如下：

- step1、启动并初始化Sentinel。

  执行 `redis-sentinel /path/to/your/sentinel.conf` 命令 或者 `redis-server /path/to/your/sentinel.conf --sentinel` 命令

  - a、使用Sentinel专用代码。

    Sentinel模式下Redis服务器只有以下功能：

    - 复制命令，比如slaveof
    - 发布与订阅功能，比如publish和subscribe
    - 文件事件处理器，比如负责发送命令请求、处理命令回复
    - 时间事件处理器，负责执行serverCron函数

  - b、初始化Sentinel状态，即初始化sentinalState结构

  - c、初始化Sentinel状态中的Master属性

  - d、创建连向主服务器的网络连接

- step2、获取主服务器信息（每10秒一次）

- step3、获取从服务器信息（每10秒一次）

- step4、向主/从服务器发送信息（每2秒一次）

- step5、接收来自主服务器和从服务器的频道信息

  - sentinel与主从服务器之间需要创建两种连接，一个是命令连接，一个是订阅连接。

  - sentinel需要通过命令连接向主从服务器发送信息，同时也需要通过订阅连接从主从服务器那接收信息。
  - 通过交换信息，来进行下面的步骤。

- step6、更新Sentinel字典

- step7、创建连向其它Sentinel的命令连接

  - 当一个Sentinel通过**订阅连接**从主服务器那获取到其它Sentinel时，它不仅会更新Sentinel字典中的实例结构，还会和新Sentinel之间互相创建新的**命令连接**，**最终监视同一个主服务器的多个Sentinel形成了相互连接的Sentinel网络**。

Sentinel模式下的服务器状态如图：

![](D:\MyGitHub\myproject\my-tools\my-csdn\Redis sentinel结构.jpg)

### 3、故障切换过程

Sentinel模式下，Sentinel初始化完成之后，在Sentinel网络中对所有的Matser和Slave进行监控。如果这时出现主服务器故障，则走如下流程。

- step1、判定主观下线（每1秒一次）

  

- step2、判定客观下线

  

- step3、选举Sentinel Leader【基于Raft协议】
  - a、
  - b、
  - c、
  - d、
  - e、
  - f、
  
- step4、选举新的主服务器。这是由领头Sentinel会在所有Slave中选出新的Master，选举规则如下：
  - a、删除列表中所有处于下线或者短线状态的Slave。
  - b、删除列表中所有最近5s内没有回复过领头Sentinel的INFO命令的Slave。
  - c、删除所有与下线Master连接断开超过down-after-milliseconds * 10毫秒的Slave。
  - d、领头Sentinel将根据Slave优先级，对列表中剩余的Slave进行排序，并选出其中优先级最高的Slave。
  - e、如果有多个具有相同优先级的Slave，那么领头Sentinel将按照Slave复制偏移量，选出其中偏移量最大的Slave。
  - f、如果有多个优先级最高，偏移量最大的Slave，那么根据运行ID最小原则选出新的Master。
  
- step5、让其余所有Slave服务器复制新的Master服务器。

- step6、让已下线的Master服务器变成新的Master服务器的Slave。


## 三、集群

相关参考：

Redis Cluster数据分片实现原理、及请求路由实现：https://blog.csdn.net/Seky_fei/article/details/107611850

Redis集群 - 图解 - 秒懂（史上最全)：https://www.cnblogs.com/crazymakercircle/p/14698576.html#autoid-h3-7-0-0

> - RedisCluster 是 Redis 的亲儿子，它是 Redis 作者自己提供的 Redis 集群化方案。
> - redis在3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的数据。cluster模式为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。
> - Redis Cluster是一种服务器Sharding技术(分片和路由都是在服务端实现)，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。

### 1、几个概念

- 槽slot、key、

- 为什么引入槽？
  - 解耦数据和节点之间的关系，简化了节点扩容和收缩难度
  - 节点自身维护槽的映射关系，不需要客户端 或 代理服务维护数据分片关系。
  - Redis Cluster的节点之间会共享消息，每个节点都知道另外节点负责管理的槽范围。每个节点只能对自己负责的槽进行维护 和 读写操作。

- 为什么是16384个槽位（2^14）?
  - 1

### 2、

### 3、
