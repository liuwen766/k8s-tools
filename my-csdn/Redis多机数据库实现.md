# Redis多机数据库

Redis数据结构与对象：https://blog.csdn.net/qq_41822345/article/details/130456081
Redis单机数据库：https://blog.csdn.net/qq_41822345/article/details/130909789

> 先总结一下Redis的四种部署模式：
>
> - 1、单机模式
>   - 概念：Redis单机模式是最简单的部署模式，Redis将数据存储在单个节点上。 
>   - 优点
>     - 简单易用。架构简单，部署方便。
>     - 低延迟高性能。毕竟是单机，少了很多的网络传输。
>   - 缺点
>     - 无法保证数据的可靠性。
>     - 处理能力有限。受限于单核CPU的处理能力。
>     - 内存容量有限 。因此一般不会用于生产环境。
>
> - 2、主从复制模式
>
>   - 概念：主从模式是指可以让一个服务器（slave）去复制另一个服务器（master）的数据。
>   - 优点
>     - 数据备份。Master能自动将数据同步到Slave，且同步是以非阻塞bgsave的方式进行的。 
>     - 读写分离。 分担Master的读压力。
>   - 缺点
>     - 不具备自动容错与恢复功能。
>     - 有数据不一致的风险。比如master宕机。
>     - 难以支持在线扩容，Redis的容量仍然受限于单机配置 
>
> - 3、哨兵模式
>
>   - 概念： 哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。
>   - 优点
>     - 主从复制模式有的优点，哨兵模式也有。
>     - 系统可用性更高。master挂掉可以自动进行切换。
>   - 缺点
>     - 主从复制模式有的优点，哨兵模式也有。
>     - 需要额外的资源来启动sentinel进程，实现相对复杂一点。
>
> - 4、集群模式
>
>   - 概念：集群模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。 
>
>   - 优点
>
>     - 无中心架构。
>     - 可维护性。降低运维成本，提高系统的扩展性和可用性。
>     - 高可扩展。可线性扩展到1000多个节点，节点可动态添加或删除。
>     - 高可用性。部分节点不可用时，集群仍可用。
>
>   - 缺点
>
>     - 架构复杂性。客户端实现的复杂性。开发难度提高。
>
>     - 数据通过异步复制，不保证数据的强一致性。
>     - slave节点只能作为数据备份，不能缓解读压力。
>     - 不支持多数据库，只有1个数据库空间db0。
>     - 运维复杂，需要面临更多问题：比如Key事务操作、big-key/hot-key的处理更加复杂。

## 一、主从复制

> 主从复制还是哨兵和集群能够实施的基础，因此可以说主从复制是Redis高可用的基石。 

主从模式是指通过执行 slaveof 命令或设置 slaveof 选项，让一个服务器（slave）去复制另一个服务器（master）的数据。

只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。

### 1、旧版复制功能的实现

Redis的复制功能分为 **同步** 和 **命令传播** 两个操作。

#### a、同步

一个redis实例变成另一个redis实例的从节点有三种方式。

- 启动前：在从服务器的配置文件中加入slaveof配置；
- 启动时：在redis-server启动命令后加入--slaveof；
- 启动后：直接在客户端执行命令：slaveof ，则该Redis实例成为从节点。

**当redis实例通过上述方式变成一个从节点后，首先要执行同步操作——通过向主服务器发送SYNC命令来完成**，步骤如下：

- step1：从服务节点向主服务器发送`sync`命令；
- step2：主服务节点执行`bgsave`命令，后台生成RDB文件的同时，并使用缓冲区记录之后的所有写命令；
- step3：主服务节点将生成的RDB文件发送给从服务器；
- step4：从服务节点载入RDB文件，将自己的数据库状态更新至主服务节点执行`bgsave`命令时的数据库状态；
- step5：主服务器将缓冲区的所有写命令发送给从服务器；
- step6：从服务器执行这些写命令，将自己与主服务节点完全同步。

#### b、命令传播

当主服务器执行新的写命令时，主从服务器就可能出现不一致状态。这时主服务器需要对从服务器执行**命令传播**操作：将写命令传播给从服务器，这也是从服务器唯一能接收写命令的方式。

### 2、旧版复制功能的缺陷

以上复制方式在从节点**初次复制**主节点时，没有什么问题，但是当**断线后重复制**时，从节点需要再次发送`sync`命令，相当于初次复制。这种为了让从服务器补足一小部分缺失的数据，但却要把所有数据重新复制一遍的做法是非常低效的。

> - `SYNC` 命令是一个非常耗费资源的操作【非必要时不要执行这个命令】
>   - 主服务器需要执行 bgsave 命令，这需要耗费主服务器大量的CPU、内存和I/O资源。
>   - 主服务器将RDB文件发送给从服务器，这占用主服务器和从服务器大量的网络资源。
>   - 从服务器在载入RDB文件的期间，会因为阻塞无法处理其它命令请求。

### 3、新版复制功能的实现

> 从Redis2.8版本开始，使用 `PSYNC` 代替 `SYNC` 命令，它有两种模式：完整同步模式和部分同步模式。
>
> 完整同步模式用于处理复制，等同于旧版复制功能。
>
> 部分同步模式解决了旧版复制功能在处理断线后重复制时出现的低效问题。
>
> 部分同步模式只需要将从服务器缺少的写命令发送给从服务器执行就可以了。

#### a、部分同步功能

部分同步功能的实现基于以下三个部分构成：

- 主服务器的复制偏移量offset。

- 主服务器的复制积压缓冲区。

- 服务器的运行ID。

  实现原理简述：从服务器发生断连时，它会向主服务器发送`PSYNC 主服务器运行ID 复制偏移量offset` 请求进行部分同步。主服务器接收到从服务器的`PSYNC`命令之后，首先对比从服务器传来的 **主服务器运行ID** ，如果和自己一致，那就检测从**复制偏移量offset**之后的数据是否存在于**复制积压缓冲区**，如果存在，则响应 `+CONTINUE`回复给从服务器，表示可以进行部分同步操作。

#### b、复制实现步骤

- step1、
- step2、
- step3、
- step4、
- step5、
- step6、
- step7、
- step8、

### 4、心跳检测



## 二、哨兵

哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。 

由一个或多个Sentinel去监听（并且Sentinel也可以互相监视）任意多个主服务以及主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已经下线的主服务器继续处理命令请求。

### 1、Sentinel初始化

### 2、Sentinel原理

### 3、Sentinel故障转移过程



![](D:\MyGitHub\my-tools\my-csdn\Redis sentinel结构.jpg)

```shell
# 放行所有 IP 限制
bind 0.0.0.0
# 进程端口号
port 26379
# 后台启动
daemonize yes
# 日志记录文件
logfile "/usr/local/redis/log/sentinel.log"
# 进程编号记录文件
pidfile /var/run/sentinel.pid
# 指示 Sentinel 去监视一个名为 mymaster 的主服务器 2为制裁权重值
sentinel monitor mymaster 192.168.10.101 6379 2
# 访问主节点的密码【如果设置密码，有必要统一密码的设置】
sentinel auth-pass mymaster 123456
# Sentinel 认为服务器已经断线所需的毫秒数
sentinel down-after-milliseconds mymaster 10000
# 若 Sentinel 在该配置值内未能完成 failover 操作，则认为本次 failover 失败
sentinel failover-timeout mymaster 180000
```

## 三、集群

集群模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。 

当遇到单机内存、并发、流量等瓶颈时，可以采用集群Cluster架构达到负载均衡的目的。

### 1、

### 2、

### 3、