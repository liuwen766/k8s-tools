# Redis多机数据库

Redis数据结构与对象：https://blog.csdn.net/qq_41822345/article/details/130456081

Redis单机数据库：https://blog.csdn.net/qq_41822345/article/details/130909789

> 先总结一下Redis的四种部署模式：
>
> - 1、单机模式
>   - 概念：Redis单机模式是最简单的部署模式，Redis将数据存储在单个节点上。 
>   - 优点
>     - 简单易用。架构简单，部署方便。
>     - 低延迟高性能。毕竟是单机，少了很多的网络传输。
>   - 缺点
>     - 无法保证数据的可靠性。
>     - 处理能力有限。受限于单核CPU的处理能力。
>     - 内存容量有限 。因此一般不会用于生产环境。
>
> - 2、主从复制模式
>
>   - 概念：主从模式是指可以让一个服务器（slave）去复制另一个服务器（master）的数据。
>   - 优点
>     - 数据备份。Master能自动将数据同步到Slave，且同步是以非阻塞bgsave的方式进行的。 
>     - 读写分离。 分担Master的读压力。
>   - 缺点
>     - 不具备自动容错与恢复功能。
>     - 有数据不一致的风险。比如master宕机。
>     - 难以支持在线扩容，Redis的容量仍然受限于单机配置 
>
> - 3、哨兵模式
>
>   - 概念： 哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。
>   - 优点
>     - 主从复制模式有的优点，哨兵模式也有。
>     - 系统可用性更高。master挂掉可以自动进行切换。
>   - 缺点
>     - 主从复制模式有的优点，哨兵模式也有。
>     - 需要额外的资源来启动sentinel进程，实现相对复杂一点。
>
> - 4、集群模式
>
>   - 概念：集群模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。 
>
>   - 优点
>
>     - 无中心架构。
>     - 可维护性。降低运维成本，提高系统的扩展性和可用性。
>     - 高可扩展。可线性扩展到1000多个节点，节点可动态添加或删除。
>     - 高可用性。部分节点不可用时，集群仍可用。
>
>   - 缺点
>
>     - 架构复杂性。客户端实现的复杂性。开发难度提高。
>
>     - 数据通过异步复制，不保证数据的强一致性。
>     - slave节点只能作为数据备份，不能缓解读压力。
>     - 不支持多数据库，只有1个数据库空间db0。
>     - 运维复杂，需要面临更多问题：比如Key事务操作、big-key/hot-key的处理更加复杂。

## 一、主从复制

> 主从复制还是哨兵和集群能够实施的基础，因此可以说主从复制是Redis高可用的基石。 

主从模式是指通过执行 slaveof 命令或设置 slaveof 选项，让一个服务器（slave）去复制另一个服务器（master）的数据。

只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。

### 1、旧版复制功能的实现

Redis的复制功能分为 **同步** 和 **命令传播** 两个操作。

#### a、同步

一个redis实例变成另一个redis实例的从节点有三种方式。

- 启动前：在从服务器的配置文件中加入slaveof配置；
- 启动时：在redis-server启动命令后加入--slaveof；
- 启动后：直接在客户端执行命令：slaveof ，则该Redis实例成为从节点。

**当redis实例通过上述方式变成一个从节点后，首先要执行同步操作——通过向主服务器发送SYNC命令来完成**，步骤如下：

- step1：从服务节点向主服务器发送`sync`命令；
- step2：主服务节点执行`bgsave`命令，后台生成RDB文件的同时，并使用缓冲区记录之后的所有写命令；
- step3：主服务节点将生成的RDB文件发送给从服务器；
- step4：从服务节点载入RDB文件，将自己的数据库状态更新至主服务节点执行`bgsave`命令时的数据库状态；
- step5：主服务器将缓冲区的所有写命令发送给从服务器；
- step6：从服务器执行这些写命令，将自己与主服务节点完全同步。

#### b、命令传播

当主服务器执行新的写命令时，主从服务器就可能出现不一致状态。这时主服务器需要对从服务器执行**命令传播**操作：将写命令传播给从服务器，这也是从服务器唯一能接收写命令的方式。

### 2、旧版复制功能的缺陷

以上复制方式在从节点**初次复制**主节点时，没有什么问题，但是当**断线后重复制**时，从节点需要再次发送`sync`命令，相当于初次复制。这种为了让从服务器补足一小部分缺失的数据，但却要把所有数据重新复制一遍的做法是非常低效的。

> - `SYNC` 命令是一个非常耗费资源的操作【非必要时不要执行这个命令】
>   - 主服务器需要执行 bgsave 命令，这需要耗费主服务器大量的CPU、内存和I/O资源。
>   - 主服务器将RDB文件发送给从服务器，这占用主服务器和从服务器大量的网络资源。
>   - 从服务器在载入RDB文件的期间，会因为阻塞无法处理其它命令请求。

### 3、新版复制功能的实现

> 从Redis2.8版本开始，使用 `PSYNC` 代替 `SYNC` 命令，它有两种模式：完整同步模式和部分同步模式。
>
> 完整同步模式用于处理复制，等同于旧版复制功能。
>
> 部分同步模式解决了旧版复制功能在处理断线后重复制时出现的低效问题。
>
> 部分同步模式只需要将从服务器缺少的写命令发送给从服务器执行就可以了。

#### a、部分同步功能

部分同步功能的实现基于以下三个部分构成：

- 主服务器的复制偏移量offset。

- 主服务器的复制积压缓冲区。

- 服务器的运行ID。

  实现原理简述：从服务器发生断连时，它会向主服务器发送`PSYNC 主服务器运行ID 复制偏移量offset` 请求进行部分同步。主服务器接收到从服务器的`PSYNC`命令之后，首先对比从服务器传来的 **主服务器运行ID** ，如果和自己一致，那就检测从**复制偏移量offset**之后的数据是否存在于**复制积压缓冲区**，如果存在，则响应 `+CONTINUE`回复给从服务器，表示可以进行部分同步操作。

#### b、复制实现步骤

- 1、连接建立阶段
  - step1、保存主节点信息
  - step2、建立socket连接
  - step3、发送ping命令
  - step4、身份验证
  - step5、发送从节点端口信息
- 2、数据同步阶段
  - step1、首先，从节点根据当前状态，决定如何调用psync命令。
    - 全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。
    - 部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。
  - step2、主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制。
    - 如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；
    - 如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；
    - 如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC ，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。
- 3、命令传播阶段
  - step1、在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
  - step2、在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：`PING` 和 `REPLCONF ACK`。

### 4、心跳检测



## 二、哨兵

哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。 

由一个或多个Sentinel去监听（并且Sentinel也可以互相监视）任意多个主服务以及主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已经下线的主服务器继续处理命令请求。

### 1、Sentinel概念

- Sentinel的三个任务
  - 监控
  - 提醒
  - 自动故障迁移

- Sentinel网络
  - sentinel本身是监督者的身份，没有存储功能。
  - 监控同一个Master的Sentinel会自动连接，组成一个分布式的Sentinel网络，互相通信并交换彼此关于被监视服务器的信息。
  - 在整个体系中一个sentinel者或一群sentinels与主从服务架构体系是监督与被监督的关系。
  - 为什么需要一个这样的Sentinel网络？
    - sentinel在整个架构体系中有如下三种交互：sentinel与主服务器、sentinel与从服务器、sentinel与其他sentinel。
    - 既然是交互，首先无可避免的就要构建这样的一个交互网络，需要节点的注册与发现、节点之间的通信连接、节点保活、节点之间的通信协议等。


### 2、故障切换过程

- step1、判定主观下线
- step2、判定客观下线
- step3、选举Sentinel Leader【基于Raft协议】
  - a、
  - b、
  - c、
  - d、
  - e、
  - f、
- step4、选举新的主服务器。这是由领头Sentinel会在所有Slave中选出新的Master，选举规则如下：
  - a、删除列表中所有处于下线或者短线状态的Slave。
  - b、删除列表中所有最近5s内没有回复过领头Sentinel的INFO命令的Slave。
  - c、删除所有与下线Master连接断开超过down-after-milliseconds * 10毫秒的Slave。
  - d、领头Sentinel将根据Slave优先级，对列表中剩余的Slave进行排序，并选出其中优先级最高的Slave。
  - e、如果有多个具有相同优先级的Slave，那么领头Sentinel将按照Slave复制偏移量，选出其中偏移量最大的Slave。
  - f、如果有多个优先级最高，偏移量最大的Slave，那么根据运行ID最小原则选出新的Master。
- step5、让其余所有Slave服务器复制新的Master服务器。
- step6、让已下线的Master服务器变成新的Master服务器的Slave。



![](D:\MyGitHub\my-tools\my-csdn\Redis sentinel结构.jpg)


## 三、集群

相关参考：

Redis Cluster数据分片实现原理、及请求路由实现：https://blog.csdn.net/Seky_fei/article/details/107611850

Redis集群 - 图解 - 秒懂（史上最全)：https://www.cnblogs.com/crazymakercircle/p/14698576.html#autoid-h3-7-0-0

> - RedisCluster 是 Redis 的亲儿子，它是 Redis 作者自己提供的 Redis 集群化方案。
> - redis在3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的数据。cluster模式为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。
> - Redis Cluster是一种服务器Sharding技术(分片和路由都是在服务端实现)，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。

### 1、几个概念

- 槽slot、key、

- 为什么引入槽？
  - 解耦数据和节点之间的关系，简化了节点扩容和收缩难度
  - 节点自身维护槽的映射关系，不需要客户端 或 代理服务维护数据分片关系。
  - Redis Cluster的节点之间会共享消息，每个节点都知道另外节点负责管理的槽范围。每个节点只能对自己负责的槽进行维护 和 读写操作。

- 为什么是16384个槽位（2^14）?
  - 1

### 2、

### 3、
